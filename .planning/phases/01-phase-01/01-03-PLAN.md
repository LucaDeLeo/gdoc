---
phase: 01-phase-01
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - gdoc/auth.py
  - gdoc/cli.py
  - tests/test_auth.py
autonomous: true
user_setup:
  - service: google-cloud-console
    why: "OAuth2 credentials required for Google Drive + Docs API access"
    env_vars: []
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Desktop application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Enable Google Drive API and Google Docs API"
        location: "Google Cloud Console -> APIs & Services -> Library"
      - task: "Download credentials.json and place in ~/.gdoc/"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Download JSON"

must_haves:
  truths:
    - "Running `gdoc auth` with credentials.json present initiates browser OAuth2 flow and stores token.json in ~/.gdoc/"
    - "Running `gdoc auth --no-browser` starts local server without opening browser and prints auth URL"
    - "Running `gdoc auth` without credentials.json prints clear error and exits with code 2"
    - "Corrupt token.json is detected, deleted, and user is prompted to re-authenticate"
    - "get_credentials() returns valid credentials from cached token without re-prompting"
    - "Expired tokens are refreshed silently via refresh_token"
    - "token.json has 0600 permissions (owner read/write only)"
  artifacts:
    - path: "gdoc/auth.py"
      provides: "OAuth2 flow, credential storage, token refresh"
      exports: ["get_credentials", "authenticate", "SCOPES", "CONFIG_DIR", "TOKEN_PATH", "CREDS_PATH"]
    - path: "tests/test_auth.py"
      provides: "Auth flow tests with mocked InstalledAppFlow"
  key_links:
    - from: "gdoc/cli.py"
      to: "gdoc/auth.py"
      via: "cmd_auth calls authenticate()"
      pattern: "from gdoc\\.auth import authenticate"
    - from: "gdoc/auth.py"
      to: "gdoc/util.py"
      via: "imports AuthError"
      pattern: "from gdoc\\.util import AuthError"
    - from: "gdoc/auth.py"
      to: "google_auth_oauthlib"
      via: "InstalledAppFlow"
      pattern: "from google_auth_oauthlib\\.flow import InstalledAppFlow"
    - from: "gdoc/auth.py"
      to: "~/.gdoc/token.json"
      via: "Credentials.from_authorized_user_file / to_json"
      pattern: "from_authorized_user_file|to_json"
---

<objective>
Implement the full OAuth2 authentication module and wire it into the CLI. This covers browser-based auth, headless auth, token caching, silent refresh, and defensive handling of corrupt credentials.

Purpose: Users can authenticate once and all subsequent commands silently reuse stored credentials. This is the gateway to all Google API functionality in later phases.
Output: Working `gdoc auth` command with browser and headless flows, plus a `get_credentials()` function for all future commands to use.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-phase-01/CONTEXT.md
@.planning/phases/01-phase-01/01-RESEARCH.md
@.planning/phases/01-phase-01/01-01-SUMMARY.md
@.planning/phases/01-phase-01/01-02-SUMMARY.md
@gdoc.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Authentication module</name>
  <files>gdoc/auth.py</files>
  <action>
Create gdoc/auth.py implementing the full OAuth2 flow per locked decisions #6, #7, #9, #11.

**Imports:**
```python
import json
import os
import sys
from pathlib import Path

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow

from gdoc.util import AuthError, CONFIG_DIR, TOKEN_PATH, CREDS_PATH
```

Note: CONFIG_DIR, TOKEN_PATH, CREDS_PATH are defined in util.py (from Plan 01-01). Import them from there to maintain a single source of truth.

**Constants:**
```python
SCOPES = [
    "https://www.googleapis.com/auth/drive",
    "https://www.googleapis.com/auth/documents",
]
```

**Functions:**

1. **get_credentials() -> Credentials** — For use by all future commands:
   - Call `_load_token()` to try loading from disk
   - If creds exist and are valid: return them
   - If creds exist, are expired, AND have a refresh_token: try `creds.refresh(Request())`. On success, call `_save_token(creds)` and return. On ANY exception during refresh (google.auth.exceptions.RefreshError, etc.), fall through to raise.
   - If none of the above: raise `AuthError("Not authenticated. Run `gdoc auth` to authenticate.")`

2. **authenticate(no_browser: bool = False) -> Credentials** — Called by `gdoc auth`:
   - **Validate credentials.json exists** (locked decision #6): If CREDS_PATH does not exist, raise `AuthError(f"credentials.json not found at {CREDS_PATH}. Download it from Google Cloud Console and place it there.")`
   - Create `InstalledAppFlow.from_client_secrets_file(str(CREDS_PATH), SCOPES)`
   - If `no_browser` is True (locked decision #9, #11): call `flow.run_local_server(port=0, open_browser=False)`. Print a message to stderr before starting: `"Visit the URL below to authorize gdoc (copy-paste into browser):\n"`. The actual URL is printed by run_local_server itself.
   - If `no_browser` is False: call `flow.run_local_server(port=0)`
   - Ensure CONFIG_DIR exists: `CONFIG_DIR.mkdir(parents=True, exist_ok=True)`
   - Call `_save_token(creds)`
   - Print success message to stderr: `"OK authenticated successfully. Credentials stored in {TOKEN_PATH}"`
   - Return creds

3. **_load_token() -> Credentials | None** — Defensive loading (locked decision #7):
   - If TOKEN_PATH does not exist: return None
   - Try: `Credentials.from_authorized_user_file(str(TOKEN_PATH), SCOPES)`
   - Catch `json.JSONDecodeError`, `ValueError`, `KeyError`:
     - Print to stderr: `"ERR: stored credentials are corrupt. Run `gdoc auth` to re-authenticate."`
     - Delete the corrupt file: `TOKEN_PATH.unlink(missing_ok=True)`
     - Return None

4. **_save_token(creds: Credentials) -> None**:
   - `CONFIG_DIR.mkdir(parents=True, exist_ok=True)`
   - `TOKEN_PATH.write_text(creds.to_json())`
   - `os.chmod(TOKEN_PATH, 0o600)` — restricted permissions per pitfall #5 from research

**Important notes:**
- The `authenticate()` function handles the interactive `gdoc auth` flow.
- The `get_credentials()` function is for all other commands — it NEVER triggers the interactive flow.
- Error messages use `ERR:` prefix per locked decision #4.
- All diagnostic output goes to stderr.
  </action>
  <verify>
Run: `python -c "from gdoc.auth import get_credentials, authenticate, SCOPES; print('auth imports OK')"` — no import errors.
Run: `python -c "from gdoc.auth import SCOPES; assert len(SCOPES) == 2; print('scopes OK')"` — 2 scopes.
  </verify>
  <done>Auth module implements full OAuth2 flow with browser and headless modes, defensive token loading, silent refresh, and restricted file permissions.</done>
</task>

<task type="auto">
  <name>Task 2: Wire auth into CLI and add auth tests</name>
  <files>gdoc/cli.py, tests/test_auth.py</files>
  <action>
**1. Modify gdoc/cli.py** — Replace the auth stub with a real handler:

Add a new function `cmd_auth(args) -> int`:
```python
def cmd_auth(args) -> int:
    """Handler for `gdoc auth`."""
    from gdoc.auth import authenticate
    authenticate(no_browser=getattr(args, "no_browser", False))
    return 0
```

Use lazy import (`from gdoc.auth import authenticate` inside the function) so that auth module is not imported when running `gdoc --help` or other commands. This avoids requiring google-auth libraries just to see help text.

In `build_parser()`, update the auth subparser to use `cmd_auth` instead of `cmd_stub`:
```python
auth_p.set_defaults(func=cmd_auth)
```

The `authenticate()` function raises `AuthError` on failure, which is caught by main()'s exception handler and mapped to exit code 2.

**2. Create tests/test_auth.py** — Mock-based auth tests:

All tests must mock external dependencies (no real OAuth2 flow, no real filesystem operations on ~/.gdoc/).

a) **test_authenticate_validates_credentials_json** (locked decision #6):
   - Mock CREDS_PATH.exists() to return False
   - Call authenticate() → should raise AuthError with "credentials.json not found"

b) **test_authenticate_browser_flow**:
   - Mock CREDS_PATH.exists() to return True
   - Mock InstalledAppFlow.from_client_secrets_file to return a mock flow
   - Mock flow.run_local_server to return mock credentials
   - Mock _save_token
   - Call authenticate(no_browser=False)
   - Assert flow.run_local_server was called without open_browser=False (or with default)

c) **test_authenticate_headless_flow** (locked decisions #9, #11):
   - Same as above but call authenticate(no_browser=True)
   - Assert flow.run_local_server was called with open_browser=False

d) **test_get_credentials_from_valid_token**:
   - Mock _load_token to return a mock Credentials with valid=True
   - Call get_credentials() → returns the credentials

e) **test_get_credentials_refreshes_expired_token** (AUTH-03):
   - Mock _load_token to return mock Credentials with valid=False, expired=True, refresh_token="xxx"
   - Mock creds.refresh() to succeed
   - Mock _save_token
   - Call get_credentials() → returns refreshed credentials
   - Assert creds.refresh was called

f) **test_get_credentials_raises_when_not_authenticated**:
   - Mock _load_token to return None
   - Call get_credentials() → raises AuthError

g) **test_load_token_handles_corrupt_file** (locked decision #7):
   - Create a tmp file with invalid JSON content
   - Patch TOKEN_PATH to point to it
   - Call _load_token() → returns None
   - Assert the corrupt file was deleted

h) **test_load_token_handles_missing_fields** (locked decision #7):
   - Create a tmp file with valid JSON but missing refresh_token
   - Patch TOKEN_PATH and mock from_authorized_user_file to raise ValueError
   - Call _load_token() → returns None

i) **test_save_token_sets_permissions**:
   - Mock credentials with to_json() returning valid JSON
   - Call _save_token with tmp directory
   - Assert file permissions are 0o600

j) **test_cmd_auth_exit_code_2_on_missing_creds**:
   - Use subprocess to run `python -m gdoc auth`
   - Set `env` to a copy of `os.environ` with `HOME` (and `USERPROFILE` on Windows) overridden to a temporary directory (use `tmp_path`) that does NOT contain `.gdoc/credentials.json`. This ensures `CREDS_PATH = Path.home() / ".gdoc" / "credentials.json"` resolves to a nonexistent path, regardless of whether the real `~/.gdoc/credentials.json` exists on the developer's machine.
   - Assert exit code is 2
   - Assert stderr contains "credentials.json not found"

Use `unittest.mock.patch` to mock:
- `gdoc.auth.CREDS_PATH` / `gdoc.auth.TOKEN_PATH` / `gdoc.auth.CONFIG_DIR` (use tmp_path)
- `gdoc.auth.InstalledAppFlow`
- `gdoc.auth.Request`
- `gdoc.auth.Credentials`

Use pytest's `tmp_path` fixture for filesystem tests (test_load_token, test_save_token).
  </action>
  <verify>
Run: `cd /Users/luca/dev/gdoc && python -m pytest tests/test_auth.py -v` — all tests pass.
Run: `cd /Users/luca/dev/gdoc && python -m pytest tests/ -v` — full suite passes.
Run: `cd /Users/luca/dev/gdoc && python -m gdoc auth 2>&1; echo "exit: $?"` — exits with code 2 (no credentials.json present), stderr contains "ERR: credentials.json not found".
  </verify>
  <done>Auth command is wired into CLI with real handler. All auth behaviors are tested: browser flow, headless flow, token refresh, corrupt token handling, missing credentials error. Running `gdoc auth` without credentials.json produces clear error with exit code 2.</done>
</task>

</tasks>

<verification>
Full test suite:
```bash
cd /Users/luca/dev/gdoc && python -m pytest tests/ -v
```
All tests across test_util.py, test_format.py, test_cli.py, test_auth.py must pass.

End-to-end CLI verification:
```bash
# Auth without credentials → clear error, exit 2
python -m gdoc auth 2>&1; echo "Exit: $?"

# Auth help shows --no-browser
python -m gdoc auth --help

# Stubs still work
python -m gdoc ls 2>&1; echo "Exit: $?"

# No command → help, exit 3
python -m gdoc 2>&1; echo "Exit: $?"
```

Verify auth module imports cleanly:
```bash
python -c "from gdoc.auth import get_credentials, authenticate; print('OK')"
```
</verification>

<success_criteria>
- `gdoc auth` with credentials.json triggers browser-based OAuth2 flow
- `gdoc auth --no-browser` prints URL and starts local server without opening browser
- `gdoc auth` without credentials.json exits with code 2 and clear error message
- Corrupt or incomplete token.json is detected, deleted, and user prompted to re-auth
- get_credentials() loads and returns valid cached credentials
- Expired tokens are silently refreshed via refresh_token
- token.json is saved with 0600 permissions
- Auth errors in any command produce exit code 2
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-phase-01/01-03-SUMMARY.md`
</output>
