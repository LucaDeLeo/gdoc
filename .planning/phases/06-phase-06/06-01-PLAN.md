# Plan 06-01: File Management — `new`, `cp`, `share`

## Goal
Implement the three file management commands (`new`, `cp`, `share`) with Drive API wrappers, CLI handlers, state seeding for newly created docs, and full test coverage. Remove `cmd_stub` after all commands are implemented.

## Context References
- **CONTEXT.md**: All 19 decisions apply. Key: state seeding (#4), pre-flight scope (#3), folder error context (#19), webViewLink in verbose/JSON (#Finding #3).
- **ROADMAP.md Phase 6**: FILE-01 (`new`), FILE-02 (`cp`), FILE-03 (`share`).
- **Existing patterns**: `gdoc/api/drive.py` for API wrappers, `gdoc/cli.py` for command handlers, `tests/test_comments_cmd.py` for test structure.

## Wave: 1 (single plan — all tasks are sequential dependencies)

---

## Tasks

### Task 1: Add Drive API wrappers in `gdoc/api/drive.py`

Add three new functions at the end of `gdoc/api/drive.py`:

**`create_doc(title, folder_id=None)`**
```python
def create_doc(title: str, folder_id: str | None = None) -> dict:
    """Create a new blank Google Doc.

    Args:
        title: Document title.
        folder_id: Optional folder ID to place the doc in.

    Returns:
        Dict with keys: id, name, version (int), webViewLink.
    """
    body = {
        "name": title,
        "mimeType": "application/vnd.google-apps.document",
    }
    if folder_id:
        body["parents"] = [folder_id]
    try:
        service = get_drive_service()
        result = (
            service.files()
            .create(
                body=body,
                fields="id, name, version, webViewLink",
            )
            .execute()
        )
        if "version" in result:
            result["version"] = int(result["version"])
        return result
    except HttpError as e:
        _translate_http_error(e, folder_id or "")
```

**`copy_doc(doc_id, title)`**
```python
def copy_doc(doc_id: str, title: str) -> dict:
    """Duplicate a Google Doc.

    Args:
        doc_id: Source document ID.
        title: Title for the copy.

    Returns:
        Dict with keys: id, name, version (int), webViewLink.
    """
    try:
        service = get_drive_service()
        result = (
            service.files()
            .copy(
                fileId=doc_id,
                body={"name": title},
                fields="id, name, version, webViewLink",
            )
            .execute()
        )
        if "version" in result:
            result["version"] = int(result["version"])
        return result
    except HttpError as e:
        _translate_http_error(e, doc_id)
```

**`create_permission(doc_id, email, role)`**
```python
def create_permission(doc_id: str, email: str, role: str) -> dict:
    """Share a document with a user.

    Args:
        doc_id: Document ID.
        email: Email address to share with.
        role: Permission role ('reader', 'writer', 'commenter').

    Returns:
        Permission resource dict from the API.
    """
    try:
        service = get_drive_service()
        result = (
            service.permissions()
            .create(
                fileId=doc_id,
                body={
                    "type": "user",
                    "role": role,
                    "emailAddress": email,
                },
                sendNotificationEmail=True,
            )
            .execute()
        )
        return result
    except HttpError as e:
        _translate_http_error(e, doc_id)
```

**Testing** (`tests/test_api_drive.py` — append new test classes):

- `TestCreateDoc`: mock `get_drive_service`, verify `files().create()` called with correct body/fields, verify version cast to int, verify folder_id sets parents, verify HttpError → GdocError/AuthError translation.
- `TestCopyDoc`: mock `get_drive_service`, verify `files().copy()` called with correct fileId/body/fields, verify version cast, verify 404 → "Document not found".
- `TestCreatePermission`: mock `get_drive_service`, verify `permissions().create()` called with correct body, verify 404/403/401 error translation.

Estimated: ~15 tests for API layer.

---

### Task 2: Implement `cmd_new` in `gdoc/cli.py`

Replace the `cmd_stub` binding for `new` with a real `cmd_new` handler.

```python
def cmd_new(args) -> int:
    """Handler for `gdoc new`."""
    title = args.title
    folder_id = None
    if getattr(args, "folder", None):
        folder_id = _resolve_doc_id(args.folder)

    from gdoc.api.drive import create_doc

    result = create_doc(title, folder_id=folder_id)
    new_id = result["id"]
    version = result.get("version")
    url = result.get("webViewLink", "")

    from gdoc.format import get_output_mode, format_json

    mode = get_output_mode(args)
    if mode == "json":
        print(format_json(id=new_id, title=result.get("name", title), url=url))
    elif mode == "verbose":
        print(f"Created: {result.get('name', title)}")
        print(f"ID: {new_id}")
        print(f"URL: {url}")
    else:
        print(new_id)

    # Seed state for the new doc (CONTEXT.md Decision #4)
    from gdoc.state import update_state_after_command

    update_state_after_command(
        new_id, None, command="new",
        quiet=False, command_version=version,
    )

    return 0
```

**Parser changes** in `build_parser()`:
- Update `new_p.set_defaults(func=cmd_stub)` → `new_p.set_defaults(func=cmd_new)`

**State seeding**: `update_state_after_command` with `command="new"` and `command_version` from the API response. Since `new` is not in the `is_read` list and `change_info` is None, the existing code path at line 109 (`if command_version is not None and command not in ("cat", "info")`) will set `state.last_version = version`. This is correct — it seeds `last_version` without setting `last_read_version` (the doc has no content to "read" yet).

**No pre-flight**: `new` creates a brand-new doc — there's no existing doc to check.

---

### Task 3: Implement `cmd_cp` in `gdoc/cli.py`

Replace the `cmd_stub` binding for `cp` with a real `cmd_cp` handler.

```python
def cmd_cp(args) -> int:
    """Handler for `gdoc cp`."""
    doc_id = _resolve_doc_id(args.doc)
    title = args.title
    quiet = getattr(args, "quiet", False)

    # Pre-flight on the source doc
    from gdoc.notify import pre_flight

    change_info = pre_flight(doc_id, quiet=quiet)

    from gdoc.api.drive import copy_doc

    result = copy_doc(doc_id, title)
    new_id = result["id"]
    version = result.get("version")
    url = result.get("webViewLink", "")

    from gdoc.format import get_output_mode, format_json

    mode = get_output_mode(args)
    if mode == "json":
        print(format_json(id=new_id, title=result.get("name", title), url=url))
    elif mode == "verbose":
        print(f"Copied: {result.get('name', title)}")
        print(f"ID: {new_id}")
        print(f"URL: {url}")
    else:
        print(new_id)

    # Update state for the source doc
    from gdoc.state import update_state_after_command

    update_state_after_command(
        doc_id, change_info, command="cp", quiet=quiet,
    )

    # Seed state for the new copy (CONTEXT.md Decision #4)
    update_state_after_command(
        new_id, None, command="cp",
        quiet=False, command_version=version,
    )

    return 0
```

**Parser changes** in `build_parser()`:
- Update `cp_p.set_defaults(func=cmd_stub)` → `cp_p.set_defaults(func=cmd_cp)`

**Pre-flight**: Yes — `cp` targets an existing doc. Follows established pattern.

**State seeding**: Two calls to `update_state_after_command`:
1. Source doc: standard state update from pre-flight.
2. New copy: seeds `last_version` for the copy so subsequent commands don't trigger "first interaction".

---

### Task 4: Implement `cmd_share` in `gdoc/cli.py`

Replace the `cmd_stub` binding for `share` with a real `cmd_share` handler.

```python
def cmd_share(args) -> int:
    """Handler for `gdoc share`."""
    doc_id = _resolve_doc_id(args.doc)
    email = args.email
    role = getattr(args, "role", "reader")
    quiet = getattr(args, "quiet", False)

    # Pre-flight awareness check (CONTEXT.md resolved item #2)
    from gdoc.notify import pre_flight

    change_info = pre_flight(doc_id, quiet=quiet)

    from gdoc.api.drive import create_permission

    create_permission(doc_id, email, role)

    from gdoc.format import get_output_mode, format_json

    mode = get_output_mode(args)
    if mode == "json":
        print(format_json(email=email, role=role, status="shared"))
    else:
        print(f"OK shared with {email} as {role}")

    # Update state for the doc
    from gdoc.state import update_state_after_command

    update_state_after_command(doc_id, change_info, command="share", quiet=quiet)

    return 0
```

**Parser changes** in `build_parser()`:
- Update `share_p.set_defaults(func=cmd_stub)` → `share_p.set_defaults(func=cmd_share)`

**Pre-flight**: Yes — `share` targets an existing doc. Consistent with `resolve`/`reopen` pattern.

---

### Task 5: Remove `cmd_stub`

After all three commands are wired up:
1. Delete the `cmd_stub` function from `gdoc/cli.py` (lines 589-592).
2. Run `bash scripts/check-no-stubs.sh` to verify no `return 4.*# STUB` patterns remain.

---

### Task 6: Tests for CLI commands

Create `tests/test_file_mgmt.py` with test classes:

**`TestCmdNew`** (~12 tests):
- `test_new_terse_output` — prints just the doc ID
- `test_new_json_output` — JSON with id, title, url
- `test_new_verbose_output` — multi-line with Created/ID/URL
- `test_new_with_folder` — passes folder_id to `create_doc`
- `test_new_folder_url_resolved` — folder URL → extracted ID via `_resolve_doc_id`
- `test_new_invalid_folder_url` — GdocError exit_code=3
- `test_new_api_error` — GdocError propagation
- `test_new_auth_error` — AuthError propagation
- `test_new_state_seeded` — `update_state_after_command` called with new doc ID and version
- `test_new_no_preflight` — `pre_flight` is NOT called
- `test_new_no_folder` — `create_doc` called with `folder_id=None`
- `test_new_state_version_cast` — version from API is int in state call

**`TestCmdCp`** (~12 tests):
- `test_cp_terse_output` — prints just the new doc ID
- `test_cp_json_output` — JSON with id, title, url
- `test_cp_verbose_output` — multi-line with Copied/ID/URL
- `test_cp_preflight_called` — `pre_flight` called on source doc
- `test_cp_source_state_updated` — state updated for source doc
- `test_cp_copy_state_seeded` — state seeded for new copy
- `test_cp_api_error` — GdocError propagation
- `test_cp_auth_error` — AuthError propagation
- `test_cp_invalid_doc_id` — GdocError exit_code=3
- `test_cp_quiet_skips_preflight_banner` — quiet=True passed through
- `test_cp_preflight_on_source_not_copy` — pre_flight uses source doc_id
- `test_cp_title_passed_to_api` — copy_doc called with correct title

**`TestCmdShare`** (~10 tests):
- `test_share_terse_output` — "OK shared with EMAIL as ROLE"
- `test_share_json_output` — JSON with email, role, status
- `test_share_default_role_reader` — role defaults to "reader"
- `test_share_writer_role` — role="writer" passed correctly
- `test_share_commenter_role` — role="commenter" passed correctly
- `test_share_preflight_called` — `pre_flight` called
- `test_share_state_updated` — state updated for doc
- `test_share_api_error` — GdocError propagation
- `test_share_auth_error` — AuthError propagation
- `test_share_invalid_doc_id` — GdocError exit_code=3

**Test helper** (at top of file):
```python
def _make_args(command, **overrides):
    defaults = {
        "command": command,
        "json": False,
        "verbose": False,
        "quiet": False,
    }
    defaults.update(overrides)
    return SimpleNamespace(**defaults)
```

**Update `tests/test_cli.py`**:
- Update `TestExitCode4OnStubs`: remove or update stub tests for `new`, `cp`, `share` (they should no longer be stubs). Add tests verifying these commands don't exit with code 4.

Estimated: ~34 new tests for CLI commands, ~15 for API = ~49 total new tests.

---

## Decisions Log

| # | Decision | Rationale |
|---|----------|-----------|
| 1 | Single plan (not split across waves) | All three commands are simple, share the same pattern, and the total scope is ~200 lines of source + ~300 lines of tests. |
| 2 | `new` outputs bare ID in terse mode | Matches agent use case — pipe the ID to the next command. JSON/verbose add title and URL. |
| 3 | `cp` outputs bare ID of the copy in terse mode | Same rationale as `new`. |
| 4 | `share` output says "OK shared with EMAIL as ROLE" | Matches existing "OK" prefix pattern (`OK written`, `OK resolved comment #X`). |
| 5 | `cmd_stub` removed entirely after all commands wired | `scripts/check-no-stubs.sh` CI gate enforces this. No other callers remain. |
| 6 | `new` does NOT call pre_flight | Creates a brand-new doc. No existing doc to check. |
| 7 | `cp` and `share` DO call pre_flight | They target existing docs. Consistent with every other doc-targeting command. |
| 8 | State seeded for new docs via existing `update_state_after_command` | No new state infrastructure needed. The `command_version` path at line 109 in `state.py` handles it correctly. |
| 9 | `webViewLink` requested in `fields` for create/copy | Avoids extra API call to get the URL. Per CONTEXT.md Finding #3. |
| 10 | `sendNotificationEmail=True` for `share` | Default Google behavior. Deferring `--no-notify` flag per CONTEXT.md Decision #6. |

## Verification Checklist
- [ ] `gdoc new "Test"` creates a doc and prints the ID
- [ ] `gdoc new "Test" --folder FOLDER_ID` creates a doc in the specified folder
- [ ] `gdoc cp DOC_ID "Copy Title"` duplicates a doc and prints the new ID
- [ ] `gdoc share DOC_ID email@example.com --role writer` shares the doc
- [ ] All three commands support `--json` and `--verbose` output modes
- [ ] `cmd_stub` is deleted and `scripts/check-no-stubs.sh` passes
- [ ] State is seeded for new/copied docs (no "first interaction" on next command)
- [ ] Pre-flight runs for `cp` and `share` but NOT for `new`
- [ ] All tests pass: `pytest tests/ -v`
- [ ] No ruff lint errors: `ruff check gdoc/ tests/`
