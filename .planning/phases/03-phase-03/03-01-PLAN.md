---
phase: 03-phase-03
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - gdoc/state.py
  - gdoc/api/comments.py
  - gdoc/api/drive.py
  - gdoc/notify.py
  - gdoc/util.py
  - tests/test_state.py
  - tests/test_comments_api.py
  - tests/test_notify.py
autonomous: true

must_haves:
  truths:
    - "Per-doc state is stored at ~/.gdoc/state/{DOC_ID}.json with atomic writes (temp + rename)"
    - "State schema includes last_seen, last_version, last_read_version, last_comment_check, known_comment_ids, known_resolved_ids"
    - "load_state returns None when no state file exists (first interaction)"
    - "save_state creates STATE_DIR with exist_ok=True and uses os.rename for atomicity"
    - "list_comments auto-paginates with includeResolved=True and returns all comments; omits startModifiedTime on first interaction"
    - "pre_flight returns a ChangeInfo object describing what changed (or None if --quiet)"
    - "Banner is printed to stderr with correct symbols: âœŽ for edits, ðŸ’¬ for new comments, â†© for replies, âœ“ for resolved, â†º for reopened"
    - "First-interaction banner shows doc title, owner, edit date, and comment counts"
    - "No-changes banner shows single line: --- no changes ---"
    - "Conflict detection compares current_version against last_read_version; None last_read_version = conflict"
    - "get_file_version returns modifiedTime, version, and lastModifyingUser fields"
  artifacts:
    - path: "gdoc/state.py"
      provides: "Per-doc state persistence with atomic writes"
      exports: ["DocState", "load_state", "save_state", "STATE_DIR"]
    - path: "gdoc/api/comments.py"
      provides: "Comments API wrapper (list_comments with pagination)"
      exports: ["list_comments"]
    - path: "gdoc/notify.py"
      provides: "Pre-flight change detection, banner formatting, conflict detection"
      exports: ["pre_flight", "ChangeInfo"]
    - path: "tests/test_state.py"
      provides: "State persistence tests"
    - path: "tests/test_comments_api.py"
      provides: "Comments API wrapper tests"
    - path: "tests/test_notify.py"
      provides: "Pre-flight and banner formatting tests"
  key_links:
    - from: "gdoc/state.py"
      to: "gdoc/util.py"
      via: "STATE_DIR constant uses CONFIG_DIR"
      pattern: "from gdoc.util import CONFIG_DIR"
    - from: "gdoc/notify.py"
      to: "gdoc/state.py"
      via: "load/save state"
      pattern: "from gdoc.state import"
    - from: "gdoc/notify.py"
      to: "gdoc/api/drive.py"
      via: "get_file_version for pre-flight"
      pattern: "from gdoc.api.drive import get_file_version"
    - from: "gdoc/notify.py"
      to: "gdoc/api/comments.py"
      via: "list_comments for pre-flight"
      pattern: "from gdoc.api.comments import list_comments"
    - from: "gdoc/api/comments.py"
      to: "gdoc/api/__init__.py"
      via: "get_drive_service import"
      pattern: "from gdoc.api import get_drive_service"
---

<objective>
Build the core awareness infrastructure: per-doc state persistence, comments API wrapper, pre-flight change detection, and banner formatting.

Purpose: These three modules (state.py, api/comments.py, notify.py) form the awareness system backbone. They must exist and be fully tested before CLI handlers can integrate them.

Output: Working state persistence, comments list API, and pre-flight check that detects doc edits, new comments, replies, resolved/reopened comments â€” with correct banner formatting on stderr.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-phase-03/CONTEXT.md
@gdoc.md
@gdoc/util.py
@gdoc/api/__init__.py
@gdoc/api/drive.py
@gdoc/format.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gdoc/state.py â€” per-doc state persistence</name>
  <files>gdoc/state.py, gdoc/util.py</files>
  <action>
**1. Add STATE_DIR constant to `gdoc/util.py`:**

Add after the existing `CREDS_PATH` line:
```python
STATE_DIR = CONFIG_DIR / "state"
```

**2. Create `gdoc/state.py`:**

```python
"""Per-document state tracking for the awareness system."""

import json
import os
import tempfile
from dataclasses import dataclass, field, asdict
from pathlib import Path

from gdoc.util import STATE_DIR


@dataclass
class DocState:
    """Tracks last-known state of a document for change detection."""
    last_seen: str = ""                          # ISO timestamp
    last_version: int | None = None              # doc version number
    last_read_version: int | None = None         # version at last cat/info
    last_comment_check: str = ""                 # ISO timestamp for comments.list
    known_comment_ids: list[str] = field(default_factory=list)
    known_resolved_ids: list[str] = field(default_factory=list)


def _state_path(doc_id: str) -> Path:
    """Return the path to a document's state file."""
    return STATE_DIR / f"{doc_id}.json"


def load_state(doc_id: str) -> DocState | None:
    """Load state for a document. Returns None if no state exists (first interaction)."""
    path = _state_path(doc_id)
    if not path.exists():
        return None
    try:
        with open(path) as f:
            data = json.load(f)
        return DocState(**{k: v for k, v in data.items() if k in DocState.__dataclass_fields__})
    except (json.JSONDecodeError, TypeError, KeyError):
        return None


def save_state(doc_id: str, state: DocState) -> None:
    """Save state atomically using temp file + rename."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    path = _state_path(doc_id)
    fd, tmp_path = tempfile.mkstemp(dir=STATE_DIR, suffix=".tmp")
    try:
        with os.fdopen(fd, "w") as f:
            json.dump(asdict(state), f)
        os.rename(tmp_path, path)
    except Exception:
        # Clean up temp file on failure
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise
```

Key design decisions (from CONTEXT.md):
- `DocState` is a dataclass with all 6 fields from Decision #1
- `load_state` returns `None` for first interaction (not an empty DocState) â€” callers use this to detect first interaction
- `save_state` uses temp file + `os.rename()` for atomicity (Decision #1)
- Unknown fields in JSON are silently ignored (forward compat)
- Corrupt state files return None (graceful degradation, same as first interaction)
  </action>
  <verify>
Run: `.venv/bin/python -c "from gdoc.state import DocState, load_state, save_state; from gdoc.util import STATE_DIR; print('imports OK'); print(STATE_DIR)"`
Run: `.venv/bin/python -c "from gdoc.state import DocState; s = DocState(); print(s)"`
  </verify>
  <done>State module loads, DocState dataclass works, STATE_DIR constant exists in util.py.</done>
</task>

<task type="auto">
  <name>Task 2: Create gdoc/api/comments.py â€” comments list with pagination</name>
  <files>gdoc/api/comments.py</files>
  <action>
Create `gdoc/api/comments.py`:

```python
"""Comments API wrapper functions (Drive API v3)."""

from googleapiclient.errors import HttpError

from gdoc.api import get_drive_service
from gdoc.util import AuthError, GdocError


def _translate_http_error(e: HttpError, file_id: str) -> None:
    """Translate HttpError for comments operations."""
    status = int(e.resp.status)
    if status == 401:
        raise AuthError("Authentication expired. Run `gdoc auth`.")
    if status == 403:
        raise GdocError(f"Permission denied: {file_id}")
    if status == 404:
        raise GdocError(f"Document not found: {file_id}")
    raise GdocError(f"API error ({status}): {e.reason}")


def list_comments(file_id: str, start_modified_time: str = "") -> list[dict]:
    """List comments on a file, auto-paginating.

    Args:
        file_id: The document ID.
        start_modified_time: ISO timestamp. Only comments modified after this
            time are returned. If empty string, all comments are returned
            (used for first interaction per CONTEXT.md Decision #3).

    Returns:
        List of comment dicts with id, content, author, resolved, modifiedTime, replies.
    """
    try:
        service = get_drive_service()
        all_comments: list[dict] = []
        page_token = None

        while True:
            params: dict = {
                "fileId": file_id,
                "includeDeleted": False,
                "includeResolved": True,
                "fields": (
                    "nextPageToken, "
                    "comments(id, content, author(displayName, emailAddress), "
                    "resolved, modifiedTime, "
                    "replies(author(displayName, emailAddress), modifiedTime, content, action))"
                ),
                "pageSize": 100,
            }
            if start_modified_time:
                params["startModifiedTime"] = start_modified_time
            if page_token:
                params["pageToken"] = page_token

            response = service.comments().list(**params).execute()
            all_comments.extend(response.get("comments", []))
            page_token = response.get("nextPageToken")
            if page_token is None:
                break

        return all_comments
    except HttpError as e:
        _translate_http_error(e, file_id)
```

Key design decisions (from CONTEXT.md):
- `includeDeleted=False` excludes deleted comments
- `includeResolved=True` ensures resolved comments are returned for resolve/reopen detection (Decision #3)
- `startModifiedTime` is omitted entirely when empty string (Decision #3 first-interaction rule)
- Pagination follows `list_files` pattern (Decision #13)
- `fields` includes reply data for `â†©` (new reply) detection (Decision #3)
  </action>
  <verify>
Run: `.venv/bin/python -c "from gdoc.api.comments import list_comments; print('import OK')"`
  </verify>
  <done>Comments API wrapper with pagination created.</done>
</task>

<task type="auto">
  <name>Task 3: Update gdoc/api/drive.py â€” add get_file_version function</name>
  <files>gdoc/api/drive.py</files>
  <action>
Add a new function `get_file_version` to `gdoc/api/drive.py` after the existing `get_file_info` function:

```python
def get_file_version(doc_id: str) -> dict:
    """Get lightweight version metadata for pre-flight checks.

    Returns dict with keys: modifiedTime, version (int), lastModifyingUser.
    This is the pre-flight API call #1 from CONTEXT.md Decision #3.
    """
    try:
        service = get_drive_service()
        result = (
            service.files()
            .get(
                fileId=doc_id,
                fields="modifiedTime, version, lastModifyingUser(displayName, emailAddress)",
            )
            .execute()
        )
        # Convert version to int (API returns string)
        if "version" in result:
            result["version"] = int(result["version"])
        return result
    except HttpError as e:
        _translate_http_error(e, doc_id)
```

Also update `get_file_info` to include `version` in its fields string. Add `version` after `size` in the fields parameter:

Change the fields string from:
```
"id, name, mimeType, modifiedTime, createdTime, "
"owners(emailAddress, displayName), "
"lastModifyingUser(emailAddress, displayName), size"
```
to:
```
"id, name, mimeType, modifiedTime, createdTime, "
"owners(emailAddress, displayName), "
"lastModifyingUser(emailAddress, displayName), size, version"
```

And convert version to int in the result (same as get_file_version):
```python
result = service.files().get(...).execute()
if "version" in result:
    result["version"] = int(result["version"])
return result
```

This enables `cmd_info` to provide version data for state updates even under `--quiet` (Decision #14).
  </action>
  <verify>
Run: `.venv/bin/python -c "from gdoc.api.drive import get_file_version; print('import OK')"`
Run: `.venv/bin/python -m pytest tests/test_api_drive.py -v` â€” existing tests still pass.
  </verify>
  <done>get_file_version function added, get_file_info updated with version field.</done>
</task>

<task type="auto">
  <name>Task 4: Create gdoc/notify.py â€” pre-flight check, banners, conflict detection</name>
  <files>gdoc/notify.py</files>
  <action>
Create `gdoc/notify.py`:

```python
"""Pre-flight change detection and notification banners."""

import sys
from dataclasses import dataclass, field
from datetime import datetime, timezone


@dataclass
class ChangeInfo:
    """Result of a pre-flight check."""
    is_first_interaction: bool = False
    doc_title: str = ""
    doc_owner: str = ""
    doc_modified: str = ""
    open_comment_count: int = 0
    resolved_comment_count: int = 0

    # Change detection results
    doc_edited: bool = False
    editor: str = ""
    old_version: int | None = None
    new_version: int | None = None

    new_comments: list[dict] = field(default_factory=list)
    new_replies: list[dict] = field(default_factory=list)
    newly_resolved: list[dict] = field(default_factory=list)
    newly_reopened: list[dict] = field(default_factory=list)

    # Pre-flight metadata for state update
    current_version: int | None = None
    preflight_timestamp: str = ""
    all_comment_ids: list[str] = field(default_factory=list)
    all_resolved_ids: list[str] = field(default_factory=list)

    @property
    def has_changes(self) -> bool:
        """True if any changes were detected."""
        return (self.doc_edited or bool(self.new_comments) or
                bool(self.new_replies) or bool(self.newly_resolved) or
                bool(self.newly_reopened))

    # Conflict detection: carried from state for has_conflict
    last_read_version: int | None = None

    @property
    def has_conflict(self) -> bool:
        """True if doc was edited since last read (Decision #7).

        Compares current_version against last_read_version, NOT last_version.
        If last_read_version is None (no prior read), treat as conflict.
        """
        if self.current_version is None:
            return False
        if self.last_read_version is None:
            return True  # No prior read = conflict
        return self.current_version != self.last_read_version


def pre_flight(doc_id: str, quiet: bool = False) -> ChangeInfo | None:
    """Run the pre-flight check for a document.

    Returns ChangeInfo with detected changes, or None if --quiet.
    Prints the notification banner to stderr.

    Per CONTEXT.md Decision #6: --quiet short-circuits before any API calls.
    """
    if quiet:
        return None

    from gdoc.state import load_state, DocState
    from gdoc.api.drive import get_file_version
    from gdoc.api.comments import list_comments

    state = load_state(doc_id)

    # Capture pre-request timestamp for last_comment_check advancement (Decision #12)
    preflight_ts = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ")

    # Carry last_read_version from state for conflict detection (Decision #7)
    last_read_version = state.last_read_version if state else None

    # Pre-flight API call #1: file version
    version_data = get_file_version(doc_id)
    current_version = version_data.get("version")
    modified_time = version_data.get("modifiedTime", "")
    last_modifier = version_data.get("lastModifyingUser", {})
    editor_name = (last_modifier.get("displayName") or
                   last_modifier.get("emailAddress", ""))

    # Pre-flight API call #2: comments
    start_time = state.last_comment_check if state else ""
    comments = list_comments(doc_id, start_modified_time=start_time)

    info = ChangeInfo(
        current_version=current_version,
        preflight_timestamp=preflight_ts,
        last_read_version=last_read_version,
    )

    if state is None:
        # First interaction â€” build first-interaction banner
        info.is_first_interaction = True
        info.doc_modified = modified_time

        # Need file metadata for title/owner â€” use version_data is lightweight,
        # get title/owner from a separate call
        from gdoc.api.drive import get_file_info
        metadata = get_file_info(doc_id)
        info.doc_title = metadata.get("name", "")
        owners = metadata.get("owners", [])
        owner = owners[0] if owners else {}
        info.doc_owner = owner.get("emailAddress") or owner.get("displayName", "")

        # Count comments
        open_count = sum(1 for c in comments if not c.get("resolved", False))
        resolved_count = sum(1 for c in comments if c.get("resolved", False))
        info.open_comment_count = open_count
        info.resolved_comment_count = resolved_count

        # Initialize comment ID sets
        info.all_comment_ids = [c["id"] for c in comments if "id" in c]
        info.all_resolved_ids = [c["id"] for c in comments if c.get("resolved", False)]

    else:
        # Subsequent interaction â€” detect changes

        # Doc edit detection (version changed)
        if current_version is not None and state.last_version is not None:
            if current_version != state.last_version:
                info.doc_edited = True
                info.editor = editor_name
                info.old_version = state.last_version
                info.new_version = current_version

        # Comment change detection
        known_ids = set(state.known_comment_ids)
        known_resolved = set(state.known_resolved_ids)

        for c in comments:
            cid = c.get("id", "")
            resolved = c.get("resolved", False)

            if cid not in known_ids:
                # New comment
                info.new_comments.append(c)
            else:
                # Existing comment â€” check for new replies and resolve/reopen
                if c.get("replies"):
                    # Check if there are replies we haven't seen
                    # (any reply on a modified comment is considered new)
                    info.new_replies.append(c)

                if resolved and cid not in known_resolved:
                    info.newly_resolved.append(c)
                elif not resolved and cid in known_resolved:
                    info.newly_reopened.append(c)

        # Build full comment ID sets for state update
        # Start with existing known IDs and merge in new data
        all_ids = set(state.known_comment_ids)
        all_resolved = set(state.known_resolved_ids)
        for c in comments:
            cid = c.get("id", "")
            if cid:
                all_ids.add(cid)
                if c.get("resolved", False):
                    all_resolved.add(cid)
                elif cid in all_resolved:
                    all_resolved.discard(cid)
        info.all_comment_ids = sorted(all_ids)
        info.all_resolved_ids = sorted(all_resolved)

    # Print the banner to stderr
    _print_banner(info, state)

    return info


def _format_time_ago(last_seen: str) -> str:
    """Format a human-readable 'time ago' string from an ISO timestamp."""
    if not last_seen:
        return ""
    try:
        then = datetime.fromisoformat(last_seen.replace("Z", "+00:00"))
        now = datetime.now(timezone.utc)
        delta = now - then
        seconds = int(delta.total_seconds())
        if seconds < 60:
            return f"{seconds} sec ago"
        minutes = seconds // 60
        if minutes < 60:
            return f"{minutes} min ago"
        hours = minutes // 60
        if hours < 24:
            return f"{hours} hr ago"
        days = hours // 24
        return f"{days} day ago" if days == 1 else f"{days} days ago"
    except (ValueError, TypeError):
        return ""


def _print_banner(info: ChangeInfo, state) -> None:
    """Print the notification banner to stderr (Decision #4)."""
    if info.is_first_interaction:
        _print_first_interaction_banner(info)
        return

    if not info.has_changes:
        print("--- no changes ---", file=sys.stderr)
        return

    # Build change lines
    time_ago = _format_time_ago(state.last_seen if state else "")
    header = f"--- since last interaction ({time_ago}) ---" if time_ago else "--- since last interaction ---"
    print(header, file=sys.stderr)

    if info.doc_edited:
        version_str = ""
        if info.old_version is not None and info.new_version is not None:
            version_str = f" (v{info.old_version} \u2192 v{info.new_version})"
        print(f" \u270e doc edited by {info.editor}{version_str}", file=sys.stderr)

    for c in info.new_comments:
        author = c.get("author", {})
        name = author.get("emailAddress") or author.get("displayName", "")
        content = c.get("content", "")
        cid = c.get("id", "")
        # Truncate long content
        if len(content) > 60:
            content = content[:57] + "..."
        print(f' \U0001f4ac new comment #{cid} by {name}: "{content}"', file=sys.stderr)

    for c in info.new_replies:
        cid = c.get("id", "")
        replies = c.get("replies", [])
        if replies:
            last_reply = replies[-1]
            author = last_reply.get("author", {})
            name = author.get("emailAddress") or author.get("displayName", "")
            content = last_reply.get("content", "")
            if len(content) > 60:
                content = content[:57] + "..."
            print(f' \u21a9 new reply on #{cid} by {name}: "{content}"', file=sys.stderr)

    for c in info.newly_resolved:
        cid = c.get("id", "")
        # The resolver is the author of the resolve reply
        replies = c.get("replies", [])
        resolver = ""
        for r in reversed(replies):
            if r.get("action") == "resolve":
                author = r.get("author", {})
                resolver = author.get("emailAddress") or author.get("displayName", "")
                break
        if not resolver:
            resolver = "unknown"
        print(f" \u2713 comment #{cid} resolved by {resolver}", file=sys.stderr)

    for c in info.newly_reopened:
        cid = c.get("id", "")
        replies = c.get("replies", [])
        reopener = ""
        for r in reversed(replies):
            if r.get("action") == "reopen":
                author = r.get("author", {})
                reopener = author.get("emailAddress") or author.get("displayName", "")
                break
        if not reopener:
            reopener = "unknown"
        print(f" \u21ba comment #{cid} reopened by {reopener}", file=sys.stderr)

    print("---", file=sys.stderr)


def _print_first_interaction_banner(info: ChangeInfo) -> None:
    """Print the first-interaction banner (Decision #8)."""
    print("--- first interaction with this doc ---", file=sys.stderr)

    modified_date = info.doc_modified[:10] if info.doc_modified else ""
    print(
        f' \U0001f4c4 "{info.doc_title}" by {info.doc_owner}, last edited {modified_date}',
        file=sys.stderr,
    )

    parts = []
    if info.open_comment_count > 0:
        parts.append(f"{info.open_comment_count} open comment{'s' if info.open_comment_count != 1 else ''}")
    if info.resolved_comment_count > 0:
        parts.append(f"{info.resolved_comment_count} resolved")
    if parts:
        print(f" \U0001f4ac {', '.join(parts)}", file=sys.stderr)

    print("---", file=sys.stderr)
```

**Important implementation notes:**
- `pre_flight` returns `None` when `--quiet` (Decision #6), short-circuiting before any imports or API calls
- First interaction triggers an extra `get_file_info` call for title/owner (Decision #8) â€” this is 3 API calls total for first interaction only
- `preflight_timestamp` is captured before API calls for `last_comment_check` advancement (Decision #12)
- Comment ID sets are built cumulatively (existing known + new from API) to avoid losing IDs
- Banner uses `print(..., file=sys.stderr)` (Decision #4)
- Symbols match the spec table: âœŽ (\u270e), ðŸ’¬ (\U0001f4ac), â†© (\u21a9), âœ“ (\u2713), â†º (\u21ba)
- `_format_time_ago` provides human-readable relative time for the banner header
  </action>
  <verify>
Run: `.venv/bin/python -c "from gdoc.notify import pre_flight, ChangeInfo; print('imports OK')"`
Run: `.venv/bin/python -c "from gdoc.notify import ChangeInfo; c = ChangeInfo(); print(c.has_changes, c.has_conflict)"`
  </verify>
  <done>Notify module with pre_flight, ChangeInfo, and banner formatting created.</done>
</task>

<task type="auto">
  <name>Task 5: Comprehensive tests for state, comments API, and notify modules</name>
  <files>tests/test_state.py, tests/test_comments_api.py, tests/test_notify.py</files>
  <action>

**1. Create `tests/test_state.py`:**

```python
"""Tests for per-doc state persistence."""

import json
from pathlib import Path
from unittest.mock import patch

import pytest

from gdoc.state import DocState, load_state, save_state, _state_path


class TestDocState:
    def test_default_values(self):
        s = DocState()
        assert s.last_seen == ""
        assert s.last_version is None
        assert s.last_read_version is None
        assert s.last_comment_check == ""
        assert s.known_comment_ids == []
        assert s.known_resolved_ids == []

    def test_custom_values(self):
        s = DocState(
            last_seen="2025-01-20T14:30:00Z",
            last_version=847,
            last_read_version=845,
            last_comment_check="2025-01-20T14:30:00Z",
            known_comment_ids=["AAA", "BBB"],
            known_resolved_ids=["CCC"],
        )
        assert s.last_version == 847
        assert s.last_read_version == 845
        assert s.known_comment_ids == ["AAA", "BBB"]


class TestSaveLoadState:
    def test_round_trip(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            state = DocState(
                last_seen="2025-01-20T14:30:00Z",
                last_version=847,
                last_read_version=845,
                last_comment_check="2025-01-20T14:30:00Z",
                known_comment_ids=["AAA", "BBB"],
                known_resolved_ids=["CCC"],
            )
            save_state("doc123", state)
            loaded = load_state("doc123")
            assert loaded is not None
            assert loaded.last_version == 847
            assert loaded.last_read_version == 845
            assert loaded.known_comment_ids == ["AAA", "BBB"]
            assert loaded.known_resolved_ids == ["CCC"]

    def test_load_nonexistent_returns_none(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            assert load_state("nonexistent") is None

    def test_load_corrupt_json_returns_none(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            path = tmp_path / "corrupt.json"
            path.write_text("not json{{{")
            with patch("gdoc.state._state_path", return_value=path):
                assert load_state("corrupt") is None

    def test_save_creates_directory(self, tmp_path):
        state_dir = tmp_path / "nested" / "state"
        with patch("gdoc.state.STATE_DIR", state_dir):
            save_state("doc1", DocState(last_seen="2025-01-20T00:00:00Z"))
            assert (state_dir / "doc1.json").exists()

    def test_save_atomic_write(self, tmp_path):
        """Verify no .tmp files are left behind after successful save."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            save_state("doc1", DocState(last_seen="2025-01-20T00:00:00Z"))
            tmp_files = list(tmp_path.glob("*.tmp"))
            assert len(tmp_files) == 0

    def test_load_ignores_unknown_fields(self, tmp_path):
        """Forward compatibility: unknown JSON keys are silently ignored."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            path = tmp_path / "doc1.json"
            data = {"last_seen": "2025-01-20T00:00:00Z", "future_field": "value"}
            path.write_text(json.dumps(data))
            loaded = load_state("doc1")
            assert loaded is not None
            assert loaded.last_seen == "2025-01-20T00:00:00Z"

    def test_state_path(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            path = _state_path("abc123")
            assert path == tmp_path / "abc123.json"
```

**2. Create `tests/test_comments_api.py`:**

```python
"""Tests for the comments API wrapper."""

from unittest.mock import patch, MagicMock

import pytest

from gdoc.api.comments import list_comments
from gdoc.util import AuthError, GdocError


def _make_http_error(status_code: int, reason: str = ""):
    """Create a mock HttpError."""
    import httplib2
    from googleapiclient.errors import HttpError
    resp = httplib2.Response({"status": str(status_code)})
    error = HttpError(resp, b"")
    if reason:
        error.reason = reason
    return error


class TestListComments:
    @patch("gdoc.api.comments.get_drive_service")
    def test_single_page(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.return_value = {
            "comments": [{"id": "c1", "content": "hello", "resolved": False}],
        }
        result = list_comments("doc1")
        assert len(result) == 1
        assert result[0]["id"] == "c1"

    @patch("gdoc.api.comments.get_drive_service")
    def test_multiple_pages(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.side_effect = [
            {"comments": [{"id": "c1"}], "nextPageToken": "page2"},
            {"comments": [{"id": "c2"}]},
        ]
        result = list_comments("doc1")
        assert len(result) == 2
        assert result[0]["id"] == "c1"
        assert result[1]["id"] == "c2"

    @patch("gdoc.api.comments.get_drive_service")
    def test_empty_result(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.return_value = {"comments": []}
        result = list_comments("doc1")
        assert result == []

    @patch("gdoc.api.comments.get_drive_service")
    def test_start_modified_time_passed(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.return_value = {"comments": []}
        list_comments("doc1", start_modified_time="2025-01-20T00:00:00Z")
        call_kwargs = mock_service.comments().list.call_args
        # The startModifiedTime should be passed
        assert "startModifiedTime" in call_kwargs.kwargs or any(
            "startModifiedTime" in str(c) for c in mock_service.comments().list.call_args_list
        )

    @patch("gdoc.api.comments.get_drive_service")
    def test_no_start_time_omits_param(self, mock_svc):
        """First interaction: startModifiedTime is omitted entirely (Decision #3)."""
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.return_value = {"comments": []}
        list_comments("doc1", start_modified_time="")
        # Verify startModifiedTime is NOT in the call params
        call_kwargs = mock_service.comments().list.call_args[1] if mock_service.comments().list.call_args else {}
        assert "startModifiedTime" not in call_kwargs


class TestCommentsErrors:
    @patch("gdoc.api.comments.get_drive_service")
    def test_401_raises_auth_error(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.side_effect = _make_http_error(401)
        with pytest.raises(AuthError):
            list_comments("doc1")

    @patch("gdoc.api.comments.get_drive_service")
    def test_404_raises_gdoc_error(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.side_effect = _make_http_error(404)
        with pytest.raises(GdocError, match="Document not found"):
            list_comments("doc1")

    @patch("gdoc.api.comments.get_drive_service")
    def test_403_raises_gdoc_error(self, mock_svc):
        mock_service = MagicMock()
        mock_svc.return_value = mock_service
        mock_service.comments().list().execute.side_effect = _make_http_error(403)
        with pytest.raises(GdocError, match="Permission denied"):
            list_comments("doc1")
```

**3. Create `tests/test_notify.py`:**

```python
"""Tests for the pre-flight notification system."""

import sys
from types import SimpleNamespace
from unittest.mock import patch, MagicMock

import pytest

from gdoc.notify import pre_flight, ChangeInfo, _format_time_ago, _print_banner
from gdoc.state import DocState


class TestChangeInfo:
    def test_no_changes(self):
        info = ChangeInfo()
        assert not info.has_changes
        assert not info.has_conflict

    def test_doc_edited(self):
        info = ChangeInfo(doc_edited=True)
        assert info.has_changes

    def test_has_conflict_version_changed_since_read(self):
        """Conflict: current_version differs from last_read_version (Decision #7)."""
        info = ChangeInfo(current_version=10, last_read_version=8)
        assert info.has_conflict

    def test_no_conflict_version_matches_read(self):
        """No conflict: current_version matches last_read_version."""
        info = ChangeInfo(current_version=10, last_read_version=10)
        assert not info.has_conflict

    def test_conflict_no_prior_read(self):
        """Conflict: last_read_version is None (never read) (Decision #7)."""
        info = ChangeInfo(current_version=10, last_read_version=None)
        assert info.has_conflict

    def test_no_conflict_no_current_version(self):
        """No conflict: current_version is None (no version data)."""
        info = ChangeInfo(current_version=None, last_read_version=5)
        assert not info.has_conflict

    def test_new_comments_only(self):
        info = ChangeInfo(new_comments=[{"id": "c1"}])
        assert info.has_changes
        assert not info.has_conflict

    def test_new_replies(self):
        info = ChangeInfo(new_replies=[{"id": "c1"}])
        assert info.has_changes

    def test_resolved(self):
        info = ChangeInfo(newly_resolved=[{"id": "c1"}])
        assert info.has_changes

    def test_reopened(self):
        info = ChangeInfo(newly_reopened=[{"id": "c1"}])
        assert info.has_changes


class TestPreFlightQuiet:
    def test_quiet_returns_none(self):
        """--quiet short-circuits before any API calls (Decision #6)."""
        result = pre_flight("doc1", quiet=True)
        assert result is None

    @patch("gdoc.api.comments.list_comments", return_value=[])
    @patch("gdoc.api.drive.get_file_version", return_value={"version": 1, "modifiedTime": "2025-01-20T00:00:00Z"})
    @patch("gdoc.api.drive.get_file_info", return_value={"name": "Test", "owners": [], "modifiedTime": "2025-01-20T00:00:00Z"})
    @patch("gdoc.state.load_state", return_value=None)
    def test_quiet_makes_no_api_calls(self, mock_load, mock_info, mock_ver, mock_comments):
        """Verify --quiet doesn't call any API functions."""
        pre_flight("doc1", quiet=True)
        mock_ver.assert_not_called()
        mock_comments.assert_not_called()
        mock_info.assert_not_called()


class TestPreFlightFirstInteraction:
    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.api.drive.get_file_info")
    @patch("gdoc.state.load_state", return_value=None)
    def test_first_interaction_banner(self, mock_load, mock_info, mock_ver, mock_comments, capsys):
        mock_ver.return_value = {"version": 10, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_info.return_value = {
            "name": "Q3 Planning Doc",
            "owners": [{"emailAddress": "alice@co.com"}],
            "modifiedTime": "2025-01-20T14:30:00Z",
        }
        mock_comments.return_value = [
            {"id": "c1", "resolved": False},
            {"id": "c2", "resolved": False},
            {"id": "c3", "resolved": True},
        ]

        result = pre_flight("doc1")
        assert result is not None
        assert result.is_first_interaction
        assert result.open_comment_count == 2
        assert result.resolved_comment_count == 1
        assert result.current_version == 10

        err = capsys.readouterr().err
        assert "first interaction with this doc" in err
        assert "Q3 Planning Doc" in err
        assert "alice@co.com" in err
        assert "2 open comments" in err
        assert "1 resolved" in err

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.api.drive.get_file_info")
    @patch("gdoc.state.load_state", return_value=None)
    def test_first_interaction_no_comments(self, mock_load, mock_info, mock_ver, mock_comments, capsys):
        mock_ver.return_value = {"version": 5, "modifiedTime": "2025-01-20T00:00:00Z", "lastModifyingUser": {}}
        mock_info.return_value = {"name": "Empty Doc", "owners": [{"emailAddress": "bob@co.com"}], "modifiedTime": "2025-01-20T00:00:00Z"}
        mock_comments.return_value = []

        result = pre_flight("doc1")
        err = capsys.readouterr().err
        assert "first interaction" in err
        assert "Empty Doc" in err
        # No comment line if 0 comments
        assert "open comment" not in err

    @patch("gdoc.api.comments.list_comments", return_value=[])
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.api.drive.get_file_info")
    @patch("gdoc.state.load_state", return_value=None)
    def test_first_interaction_initializes_comment_ids(self, mock_load, mock_info, mock_ver, mock_comments):
        mock_ver.return_value = {"version": 5, "modifiedTime": "2025-01-20T00:00:00Z", "lastModifyingUser": {}}
        mock_info.return_value = {"name": "Doc", "owners": [], "modifiedTime": "2025-01-20T00:00:00Z"}
        mock_comments.return_value = [
            {"id": "c1", "resolved": False},
            {"id": "c2", "resolved": True},
        ]
        result = pre_flight("doc1")
        assert "c1" in result.all_comment_ids
        assert "c2" in result.all_comment_ids
        assert "c2" in result.all_resolved_ids
        assert "c1" not in result.all_resolved_ids


class TestPreFlightChanges:
    def _make_state(self, **overrides):
        defaults = {
            "last_seen": "2025-01-20T14:30:00Z",
            "last_version": 847,
            "last_read_version": 845,
            "last_comment_check": "2025-01-20T14:30:00Z",
            "known_comment_ids": ["c1", "c2"],
            "known_resolved_ids": [],
        }
        defaults.update(overrides)
        return DocState(**defaults)

    @patch("gdoc.api.comments.list_comments", return_value=[])
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_no_changes_banner(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state()
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}

        result = pre_flight("doc1")
        assert not result.has_changes
        err = capsys.readouterr().err
        assert "no changes" in err

    @patch("gdoc.api.comments.list_comments", return_value=[])
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_doc_edited_detection(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state(last_version=847)
        mock_ver.return_value = {
            "version": 851,
            "modifiedTime": "2025-01-20T15:00:00Z",
            "lastModifyingUser": {"emailAddress": "alice@co.com"},
        }

        result = pre_flight("doc1")
        assert result.doc_edited
        assert result.has_conflict
        assert result.editor == "alice@co.com"
        assert result.old_version == 847
        assert result.new_version == 851

        err = capsys.readouterr().err
        assert "\u270e" in err or "doc edited" in err
        assert "alice@co.com" in err
        assert "v847" in err
        assert "v851" in err

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_new_comment_detection(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state(known_comment_ids=["c1"])
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_comments.return_value = [
            {"id": "c2", "content": "New comment here", "resolved": False,
             "author": {"emailAddress": "carol@co.com"}},
        ]

        result = pre_flight("doc1")
        assert len(result.new_comments) == 1
        err = capsys.readouterr().err
        assert "carol@co.com" in err
        assert "New comment here" in err

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_resolved_comment_detection(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state(known_comment_ids=["c1"], known_resolved_ids=[])
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_comments.return_value = [
            {"id": "c1", "resolved": True, "replies": [
                {"action": "resolve", "author": {"emailAddress": "alice@co.com"}}
            ]},
        ]

        result = pre_flight("doc1")
        assert len(result.newly_resolved) == 1
        err = capsys.readouterr().err
        assert "\u2713" in err or "resolved" in err
        assert "alice@co.com" in err

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_reopened_comment_detection(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state(known_comment_ids=["c1"], known_resolved_ids=["c1"])
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_comments.return_value = [
            {"id": "c1", "resolved": False, "replies": [
                {"action": "reopen", "author": {"emailAddress": "bob@co.com"}}
            ]},
        ]

        result = pre_flight("doc1")
        assert len(result.newly_reopened) == 1
        err = capsys.readouterr().err
        assert "\u21ba" in err or "reopened" in err

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_new_reply_detection(self, mock_load, mock_ver, mock_comments, capsys):
        mock_load.return_value = self._make_state(known_comment_ids=["c1"])
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_comments.return_value = [
            {"id": "c1", "resolved": False, "replies": [
                {"author": {"emailAddress": "bob@co.com"}, "content": "Done"},
            ]},
        ]

        result = pre_flight("doc1")
        assert len(result.new_replies) == 1
        err = capsys.readouterr().err
        assert "bob@co.com" in err

    @patch("gdoc.api.comments.list_comments", return_value=[])
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_preflight_timestamp_captured(self, mock_load, mock_ver, mock_comments):
        mock_load.return_value = self._make_state()
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}

        result = pre_flight("doc1")
        assert result.preflight_timestamp != ""
        # Should be a valid ISO timestamp
        assert "T" in result.preflight_timestamp

    @patch("gdoc.api.comments.list_comments")
    @patch("gdoc.api.drive.get_file_version")
    @patch("gdoc.state.load_state")
    def test_comment_ids_accumulated(self, mock_load, mock_ver, mock_comments):
        """Comment IDs from both state and new API results are merged."""
        mock_load.return_value = self._make_state(known_comment_ids=["c1", "c2"])
        mock_ver.return_value = {"version": 847, "modifiedTime": "2025-01-20T14:30:00Z", "lastModifyingUser": {}}
        mock_comments.return_value = [
            {"id": "c3", "resolved": False},
        ]

        result = pre_flight("doc1")
        assert "c1" in result.all_comment_ids
        assert "c2" in result.all_comment_ids
        assert "c3" in result.all_comment_ids


class TestFormatTimeAgo:
    def test_empty_string(self):
        assert _format_time_ago("") == ""

    def test_invalid_timestamp(self):
        assert _format_time_ago("not-a-date") == ""

    @patch("gdoc.notify.datetime")
    def test_seconds_ago(self, mock_dt):
        from datetime import datetime, timezone, timedelta
        now = datetime(2025, 1, 20, 14, 30, 30, tzinfo=timezone.utc)
        mock_dt.now.return_value = now
        mock_dt.fromisoformat = datetime.fromisoformat
        assert _format_time_ago("2025-01-20T14:30:00Z") == "30 sec ago"

    @patch("gdoc.notify.datetime")
    def test_minutes_ago(self, mock_dt):
        from datetime import datetime, timezone
        now = datetime(2025, 1, 20, 14, 35, 0, tzinfo=timezone.utc)
        mock_dt.now.return_value = now
        mock_dt.fromisoformat = datetime.fromisoformat
        assert _format_time_ago("2025-01-20T14:30:00Z") == "5 min ago"

    @patch("gdoc.notify.datetime")
    def test_hours_ago(self, mock_dt):
        from datetime import datetime, timezone
        now = datetime(2025, 1, 20, 17, 30, 0, tzinfo=timezone.utc)
        mock_dt.now.return_value = now
        mock_dt.fromisoformat = datetime.fromisoformat
        assert _format_time_ago("2025-01-20T14:30:00Z") == "3 hr ago"

    @patch("gdoc.notify.datetime")
    def test_days_ago(self, mock_dt):
        from datetime import datetime, timezone
        now = datetime(2025, 1, 23, 14, 30, 0, tzinfo=timezone.utc)
        mock_dt.now.return_value = now
        mock_dt.fromisoformat = datetime.fromisoformat
        assert _format_time_ago("2025-01-20T14:30:00Z") == "3 days ago"

    @patch("gdoc.notify.datetime")
    def test_one_day_ago(self, mock_dt):
        from datetime import datetime, timezone
        now = datetime(2025, 1, 21, 14, 30, 0, tzinfo=timezone.utc)
        mock_dt.now.return_value = now
        mock_dt.fromisoformat = datetime.fromisoformat
        assert _format_time_ago("2025-01-20T14:30:00Z") == "1 day ago"
```

**Test coverage summary:**
- `test_state.py`: DocState defaults, round-trip save/load, nonexistent returns None, corrupt JSON returns None, directory creation, atomic writes (no leftover .tmp), unknown field tolerance
- `test_comments_api.py`: Single page, multi-page pagination, empty result, startModifiedTime passed/omitted, error translation (401/403/404)
- `test_notify.py`: ChangeInfo properties, --quiet returns None and makes no API calls, first interaction banner (with/without comments, comment ID initialization), change detection (doc edited, new comments, resolved, reopened, new replies), preflight timestamp capture, comment ID accumulation, time-ago formatting
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_state.py tests/test_comments_api.py tests/test_notify.py -v`
Run: `.venv/bin/python -m pytest tests/ -v` â€” full suite passes (existing 121 tests + new tests).
  </verify>
  <done>All awareness infrastructure tests pass. State persistence, comments API, and notify module are fully tested.</done>
</task>

</tasks>

<verification>
1. `gdoc/state.py` exists with `DocState`, `load_state`, `save_state`, `STATE_DIR`
2. `gdoc/api/comments.py` exists with `list_comments` (paginated, error-translated)
3. `gdoc/api/drive.py` has new `get_file_version` function and `get_file_info` includes `version` field
4. `gdoc/notify.py` exists with `pre_flight`, `ChangeInfo`, banner formatting
5. All tests pass: `.venv/bin/python -m pytest tests/ -v`
6. State round-trip works (save + load preserves all fields)
7. `--quiet` short-circuits before any API call
8. First-interaction banner shows doc metadata and comment counts
9. Change detection catches edits, new comments, replies, resolved, reopened
</verification>

<success_criteria>
- DocState dataclass has all 6 fields matching CONTEXT.md Decision #1
- Atomic writes use temp file + os.rename (no corrupt state on crash)
- list_comments auto-paginates with includeResolved=True and handles first-interaction (no startModifiedTime)
- pre_flight returns None for --quiet (no API calls made)
- First-interaction banner matches spec format from gdoc.md L186-193
- No-changes banner is single line: "--- no changes ---"
- Change banner uses correct symbols: âœŽ ðŸ’¬ â†© âœ“ â†º
- Conflict detection compares current_version vs last_read_version (not last_version); None = conflict
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/03-phase-03/03-01-SUMMARY.md`
</output>
