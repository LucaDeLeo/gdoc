---
phase: 03-phase-03
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - gdoc/cli.py
  - gdoc/state.py
  - tests/test_cat.py
  - tests/test_info.py
  - tests/test_cli.py
autonomous: true

must_haves:
  truths:
    - "`cmd_cat` runs pre_flight before export and updates state after success"
    - "`cmd_cat` with --quiet skips pre_flight entirely (no API overhead)"
    - "`cmd_info` runs pre_flight before metadata fetch and updates state after success"
    - "`cmd_info` with --quiet skips pre_flight but still gets version from its own get_file_info response"
    - "State update after cmd_cat sets last_read_version from pre-flight data"
    - "State update after cmd_info sets last_read_version from get_file_info response"
    - "--quiet cat does not update last_version or last_read_version (Decision #14 staleness)"
    - "--quiet info updates last_version and last_read_version from command response"
    - "First interaction initializes all state fields after command success"
    - "Conflict detection logic exists: has_conflict property on ChangeInfo is testable"
    - "Banner appears on stderr before command output on stdout"
    - "All DOC_ID commands (including share and cp) accept --quiet flag"
  artifacts:
    - path: "gdoc/cli.py"
      provides: "CLI handlers with awareness integration"
      exports: ["cmd_cat", "cmd_info"]
    - path: "gdoc/state.py"
      provides: "update_state_after_command helper"
      exports: ["update_state_after_command"]
    - path: "tests/test_cat.py"
      provides: "cat command tests with awareness integration"
    - path: "tests/test_info.py"
      provides: "info command tests with awareness integration"
  key_links:
    - from: "gdoc/cli.py"
      to: "gdoc/notify.py"
      via: "pre_flight call in cmd_cat and cmd_info"
      pattern: "from gdoc.notify import pre_flight"
    - from: "gdoc/cli.py"
      to: "gdoc/state.py"
      via: "state update after successful command"
      pattern: "from gdoc.state import"
---

<objective>
Integrate the awareness system into existing CLI handlers (cmd_cat, cmd_info) with full state lifecycle: pre-flight check before execution, state update after success.

Purpose: This wires the awareness infrastructure from Plan 03-01 into the actual CLI commands. After this plan, `gdoc cat` and `gdoc info` will show awareness banners and track state. The conflict detection logic (warn for edit, block for write) is also added to `state.py` as a helper ready for Phase 4.

Output: Working awareness banners on `cat` and `info`, state persistence across invocations, --quiet bypass, and the state update helper for future commands.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-phase-03/CONTEXT.md
@.planning/phases/03-phase-03/03-01-PLAN.md
@gdoc.md
@gdoc/cli.py
@gdoc/state.py
@gdoc/notify.py
@gdoc/api/drive.py
@tests/test_cat.py
@tests/test_info.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add update_state_after_command helper to state.py</name>
  <files>gdoc/state.py</files>
  <action>
Add a helper function to `gdoc/state.py` that encapsulates the state update logic after a command succeeds. This centralizes the complex state update rules from CONTEXT.md Decisions #6, #9, #14.

Add this function after `save_state`:

```python
def update_state_after_command(
    doc_id: str,
    change_info,  # ChangeInfo | None (from pre_flight)
    command: str,
    quiet: bool = False,
    command_version: int | None = None,
) -> None:
    """Update per-doc state after a successful command.

    Args:
        doc_id: The document ID.
        change_info: ChangeInfo from pre_flight, or None if --quiet.
        command: The command name (e.g., "cat", "info", "edit").
        quiet: Whether --quiet was passed.
        command_version: Version from command's own API response (for info command).
            Used when --quiet skips pre-flight but the command itself fetches version.
    """
    from datetime import datetime, timezone

    state = load_state(doc_id) or DocState()
    now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%fZ")
    state.last_seen = now

    is_read = command in ("cat", "info")

    if quiet:
        # Decision #14: --quiet state update rules
        # cat: version stays stale (no source for version data)
        # info: version comes from command_version (get_file_info response)
        if command == "info" and command_version is not None:
            state.last_version = command_version
            state.last_read_version = command_version
        # For --quiet cat: last_version and last_read_version are NOT updated
        # last_comment_check is NOT updated (Decision #6 freeze rule)
        # known_comment_ids/known_resolved_ids NOT updated (no data source)
    elif change_info is not None:
        # Normal (non-quiet) run: update from pre-flight data
        if change_info.current_version is not None:
            state.last_version = change_info.current_version
            if is_read:
                state.last_read_version = change_info.current_version

        # Advance last_comment_check to pre-request timestamp (Decision #12)
        if change_info.preflight_timestamp:
            state.last_comment_check = change_info.preflight_timestamp

        # Update comment ID sets
        if change_info.all_comment_ids:
            state.known_comment_ids = change_info.all_comment_ids
        if change_info.all_resolved_ids is not None:
            state.known_resolved_ids = change_info.all_resolved_ids

    save_state(doc_id, state)
```

Key design decisions:
- `change_info` is the ChangeInfo from pre_flight (or None if quiet)
- `command_version` provides version data from a command's own response (used by `info` under --quiet, per Decision #14)
- For `--quiet cat`: version fields stay stale, comment fields stay frozen — this is correct per Decision #14
- For `--quiet info`: version comes from `get_file_info()` which the info command calls anyway
- `last_comment_check` only advances on non-quiet runs (Decision #6 freeze rule + Decision #12)
- Comment ID sets are replaced wholesale from change_info (which already merged existing + new IDs)
  </action>
  <verify>
Run: `.venv/bin/python -c "from gdoc.state import update_state_after_command; print('import OK')"`
  </verify>
  <done>State update helper function handles all Decision #6/#14 rules.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate pre-flight into cmd_cat</name>
  <files>gdoc/cli.py</files>
  <action>
Modify `cmd_cat` in `gdoc/cli.py` to call pre_flight before execution and update state after success.

Replace the current `cmd_cat` function with:

```python
def cmd_cat(args) -> int:
    """Handler for `gdoc cat`."""
    doc_id = _resolve_doc_id(args.doc)

    if getattr(args, "comments", False):
        print("ERR: cat --comments is not yet implemented", file=sys.stderr)
        return 4  # STUB — removed when real implementation added

    # Pre-flight awareness check (Decision #11)
    quiet = getattr(args, "quiet", False)
    from gdoc.notify import pre_flight
    change_info = pre_flight(doc_id, quiet=quiet)

    mime_type = "text/plain" if getattr(args, "plain", False) else "text/markdown"

    from gdoc.api.drive import export_doc

    content = export_doc(doc_id, mime_type=mime_type)

    from gdoc.format import get_output_mode, format_json

    mode = get_output_mode(args)
    if mode == "json":
        print(format_json(content=content))
    else:
        print(content, end="")

    # Update state after success
    from gdoc.state import update_state_after_command
    update_state_after_command(doc_id, change_info, command="cat", quiet=quiet)

    return 0
```

Key changes:
- Added `pre_flight(doc_id, quiet=quiet)` call after resolving doc_id but before export
- `pre_flight` is lazy-imported (consistent with existing pattern)
- `--comments` stub returns early BEFORE pre_flight (no point running awareness on a stub)
- State update happens AFTER successful export (not on error)
- `quiet` flag passed through to both pre_flight and update_state_after_command
- No `command_version` passed for cat (Decision #14: cat under --quiet has stale version)
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_cat.py -v` — existing tests still pass (pre_flight needs to be mocked in tests).
  </verify>
  <done>cmd_cat has pre-flight and state update integrated.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate pre-flight into cmd_info</name>
  <files>gdoc/cli.py</files>
  <action>
Modify `cmd_info` in `gdoc/cli.py` to call pre_flight before execution and update state after success. Note: `cmd_info` already calls `get_file_info()` which provides version data, so under `--quiet` we can extract the version from the command's own response.

Replace the current `cmd_info` function with:

```python
def cmd_info(args) -> int:
    """Handler for `gdoc info`."""
    doc_id = _resolve_doc_id(args.doc)

    # Pre-flight awareness check
    quiet = getattr(args, "quiet", False)
    from gdoc.notify import pre_flight
    change_info = pre_flight(doc_id, quiet=quiet)

    from gdoc.api.drive import get_file_info, export_doc
    from gdoc.format import get_output_mode, format_json

    metadata = get_file_info(doc_id)
    try:
        text = export_doc(doc_id, mime_type="text/plain")
        word_count = len(text.split())
    except GdocError as e:
        if "file is not a Google Docs editor document" in str(e):
            word_count = None
        else:
            raise

    title = metadata.get("name", "")
    owners = metadata.get("owners", [])
    owner_info = owners[0] if owners else {}
    owner = owner_info.get("displayName") or owner_info.get("emailAddress", "Unknown")
    modified = metadata.get("modifiedTime", "")
    created = metadata.get("createdTime", "")
    last_editor_info = metadata.get("lastModifyingUser", {})
    last_editor = last_editor_info.get("displayName") or last_editor_info.get(
        "emailAddress", ""
    )
    mime_type = metadata.get("mimeType", "")
    size = metadata.get("size")

    mode = get_output_mode(args)

    words_display = word_count if word_count is not None else "N/A"

    if mode == "json":
        print(
            format_json(
                id=doc_id,
                title=title,
                owner=owner,
                modified=modified,
                words=words_display,
            )
        )
    elif mode == "verbose":
        print(f"Title: {title}")
        print(f"Owner: {owner}")
        print(f"Modified: {modified}")
        print(f"Created: {created}")
        print(f"Last editor: {last_editor}")
        print(f"Type: {mime_type}")
        print(f"Size: {size or 'N/A'}")
        print(f"Words: {words_display}")
    else:
        print(f"Title: {title}")
        print(f"Owner: {owner}")
        print(f"Modified: {modified[:10]}")
        print(f"Words: {words_display}")

    # Update state after success
    # info gets version from its own get_file_info response (Decision #14)
    command_version = metadata.get("version")
    if command_version is not None:
        command_version = int(command_version)
    from gdoc.state import update_state_after_command
    update_state_after_command(
        doc_id, change_info, command="info",
        quiet=quiet, command_version=command_version,
    )

    return 0
```

Key changes:
- Added `pre_flight(doc_id, quiet=quiet)` before metadata fetch
- State update passes `command_version` from `get_file_info()` response — this enables version tracking even under `--quiet` (Decision #14: info always has version data from its own API call)
- Version conversion to int (API returns string) with None check
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_info.py -v` — existing tests still pass (pre_flight needs mocking).
  </verify>
  <done>cmd_info has pre-flight and state update integrated, with version extraction from command response.</done>
</task>

<task type="auto">
  <name>Task 4: Update test_cat.py for awareness integration</name>
  <files>tests/test_cat.py</files>
  <action>
Update `tests/test_cat.py` to mock the pre_flight and state update calls, and add new tests for awareness behavior.

**1. Update existing tests** to mock pre_flight and update_state_after_command:

All existing tests need an additional mock for `gdoc.cli.pre_flight` (or `gdoc.notify.pre_flight`). Since cmd_cat imports pre_flight inside the function with `from gdoc.notify import pre_flight`, we mock `gdoc.notify.pre_flight`.

Add these patches to all existing test methods:
```python
@patch("gdoc.notify.pre_flight", return_value=None)
@patch("gdoc.state.update_state_after_command")
```

The `pre_flight` mock returns `None` (simulating --quiet behavior) so existing tests don't need banner assertions.

**2. Add new test class `TestCatAwareness`:**

```python
class TestCatAwareness:
    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="content")
    def test_preflight_called_before_export(self, mock_export, _svc, mock_pf, mock_update):
        """pre_flight is called before export_doc."""
        mock_pf.return_value = ChangeInfo()
        args = _make_args()
        cmd_cat(args)
        mock_pf.assert_called_once_with("abc123", quiet=False)
        mock_export.assert_called_once()

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight", return_value=None)
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="content")
    def test_quiet_skips_preflight(self, mock_export, _svc, mock_pf, mock_update):
        """--quiet passes quiet=True to pre_flight."""
        args = _make_args(quiet=True)
        cmd_cat(args)
        mock_pf.assert_called_once_with("abc123", quiet=True)

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="content")
    def test_state_updated_after_success(self, mock_export, _svc, mock_pf, mock_update):
        """State is updated after successful cat."""
        change_info = ChangeInfo(current_version=10)
        mock_pf.return_value = change_info
        args = _make_args()
        cmd_cat(args)
        mock_update.assert_called_once_with(
            "abc123", change_info, command="cat", quiet=False,
        )

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="content")
    def test_state_updated_with_quiet(self, mock_export, _svc, mock_pf, mock_update):
        """State update under --quiet passes quiet=True and change_info=None."""
        mock_pf.return_value = None
        args = _make_args(quiet=True)
        cmd_cat(args)
        mock_update.assert_called_once_with(
            "abc123", None, command="cat", quiet=True,
        )

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    def test_comments_stub_skips_preflight(self, mock_pf, mock_update):
        """--comments stub returns before pre_flight is called."""
        args = _make_args(comments=True)
        rc = cmd_cat(args)
        assert rc == 4
        mock_pf.assert_not_called()
        mock_update.assert_not_called()

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", side_effect=GdocError("API error"))
    def test_no_state_update_on_error(self, mock_export, _svc, mock_pf, mock_update):
        """State is NOT updated when export_doc raises an error."""
        mock_pf.return_value = ChangeInfo()
        args = _make_args()
        with pytest.raises(GdocError):
            cmd_cat(args)
        mock_update.assert_not_called()
```

Add `from gdoc.notify import ChangeInfo` to the test file imports.

**3. Update existing test mocks:**

For each existing test class (TestCatMarkdown, TestCatPlain, TestCatJson, TestCatComments, TestCatErrors), add the `@patch("gdoc.notify.pre_flight", return_value=None)` and `@patch("gdoc.state.update_state_after_command")` decorators. Adjust parameter order in test method signatures (patches are applied in bottom-up order).

Note: The `TestCatComments` and `TestCatErrors.test_cat_invalid_doc_id`/`test_cat_empty_doc_id` tests don't need the notify mock because they fail before pre_flight is called (comments returns early, invalid doc_id raises before pre_flight).

For `TestCatErrors.test_cat_api_error`: add the notify mocks since pre_flight runs before export_doc.
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_cat.py -v` — all tests pass (existing + new).
  </verify>
  <done>cat tests updated with awareness mocks and new awareness-specific tests.</done>
</task>

<task type="auto">
  <name>Task 5: Update test_info.py for awareness integration</name>
  <files>tests/test_info.py</files>
  <action>
Update `tests/test_info.py` to mock pre_flight and state update calls, and add awareness-specific tests.

Read the existing `tests/test_info.py` first to understand its structure, then:

**1. Update existing tests** to add pre_flight and state update mocks (same pattern as test_cat.py).

**2. Add new test class `TestInfoAwareness`:**

```python
class TestInfoAwareness:
    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="hello world")
    @patch("gdoc.api.drive.get_file_info")
    def test_preflight_called(self, mock_info, mock_export, _svc, mock_pf, mock_update):
        mock_info.return_value = _sample_metadata()
        mock_pf.return_value = ChangeInfo()
        args = _make_args()
        cmd_info(args)
        mock_pf.assert_called_once_with("abc123", quiet=False)

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight", return_value=None)
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="hello world")
    @patch("gdoc.api.drive.get_file_info")
    def test_quiet_passes_through(self, mock_info, mock_export, _svc, mock_pf, mock_update):
        mock_info.return_value = _sample_metadata()
        args = _make_args(quiet=True)
        cmd_info(args)
        mock_pf.assert_called_once_with("abc123", quiet=True)

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="hello world")
    @patch("gdoc.api.drive.get_file_info")
    def test_state_updated_with_version(self, mock_info, mock_export, _svc, mock_pf, mock_update):
        """State update receives version from get_file_info response."""
        mock_info.return_value = {**_sample_metadata(), "version": 42}
        change_info = ChangeInfo()
        mock_pf.return_value = change_info
        args = _make_args()
        cmd_info(args)
        mock_update.assert_called_once_with(
            "abc123", change_info, command="info",
            quiet=False, command_version=42,
        )

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight", return_value=None)
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.export_doc", return_value="hello world")
    @patch("gdoc.api.drive.get_file_info")
    def test_quiet_info_still_gets_version(self, mock_info, mock_export, _svc, mock_pf, mock_update):
        """--quiet info still passes command_version from get_file_info (Decision #14)."""
        mock_info.return_value = {**_sample_metadata(), "version": 99}
        args = _make_args(quiet=True)
        cmd_info(args)
        mock_update.assert_called_once_with(
            "abc123", None, command="info",
            quiet=True, command_version=99,
        )

    @patch("gdoc.state.update_state_after_command")
    @patch("gdoc.notify.pre_flight")
    @patch("gdoc.api.drive.get_drive_service")
    @patch("gdoc.api.drive.get_file_info", side_effect=GdocError("not found"))
    def test_no_state_update_on_error(self, mock_info, _svc, mock_pf, mock_update):
        mock_pf.return_value = ChangeInfo()
        args = _make_args()
        with pytest.raises(GdocError):
            cmd_info(args)
        mock_update.assert_not_called()
```

Add a `_sample_metadata` helper:
```python
def _sample_metadata():
    return {
        "name": "Test Doc",
        "owners": [{"emailAddress": "alice@co.com", "displayName": "Alice"}],
        "modifiedTime": "2025-01-20T14:30:00Z",
        "createdTime": "2025-01-15T10:00:00Z",
        "lastModifyingUser": {"emailAddress": "alice@co.com", "displayName": "Alice"},
        "mimeType": "application/vnd.google-apps.document",
        "size": None,
    }
```

Add `from gdoc.notify import ChangeInfo` to the test file imports.

**3. Update existing test mocks** with the same `@patch("gdoc.notify.pre_flight", return_value=None)` and `@patch("gdoc.state.update_state_after_command")` decorators.
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_info.py -v` — all tests pass.
  </verify>
  <done>info tests updated with awareness mocks and version-passing tests.</done>
</task>

<task type="auto">
  <name>Task 6: Add state update integration tests</name>
  <files>tests/test_state.py</files>
  <action>
Add tests for `update_state_after_command` to `tests/test_state.py`:

```python
from gdoc.state import update_state_after_command

class TestUpdateStateAfterCommand:
    def _make_change_info(self, **overrides):
        """Create a mock ChangeInfo-like object."""
        from types import SimpleNamespace
        defaults = {
            "current_version": 10,
            "preflight_timestamp": "2025-01-20T14:30:00.000000Z",
            "all_comment_ids": ["c1", "c2"],
            "all_resolved_ids": ["c2"],
        }
        defaults.update(overrides)
        return SimpleNamespace(**defaults)

    def test_normal_cat_updates_all_fields(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            info = self._make_change_info(current_version=42)
            update_state_after_command("doc1", info, command="cat", quiet=False)
            state = load_state("doc1")
            assert state.last_version == 42
            assert state.last_read_version == 42  # cat is a read
            assert state.last_comment_check == "2025-01-20T14:30:00.000000Z"
            assert state.known_comment_ids == ["c1", "c2"]
            assert state.known_resolved_ids == ["c2"]

    def test_normal_info_updates_all_fields(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            info = self._make_change_info(current_version=50)
            update_state_after_command("doc1", info, command="info", quiet=False)
            state = load_state("doc1")
            assert state.last_version == 50
            assert state.last_read_version == 50  # info is a read

    def test_quiet_cat_version_stays_stale(self, tmp_path):
        """Decision #14: --quiet cat does not update version fields."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            # Pre-populate with existing state
            save_state("doc1", DocState(last_version=10, last_read_version=10))
            update_state_after_command("doc1", None, command="cat", quiet=True)
            state = load_state("doc1")
            assert state.last_version == 10  # unchanged
            assert state.last_read_version == 10  # unchanged
            assert state.last_seen != ""  # last_seen IS updated

    def test_quiet_info_version_from_command(self, tmp_path):
        """Decision #14: --quiet info updates version from command response."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            save_state("doc1", DocState(last_version=10, last_read_version=10))
            update_state_after_command(
                "doc1", None, command="info",
                quiet=True, command_version=20,
            )
            state = load_state("doc1")
            assert state.last_version == 20
            assert state.last_read_version == 20

    def test_quiet_does_not_advance_comment_check(self, tmp_path):
        """Decision #6: --quiet does not advance last_comment_check."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            save_state("doc1", DocState(last_comment_check="2025-01-20T00:00:00Z"))
            update_state_after_command("doc1", None, command="cat", quiet=True)
            state = load_state("doc1")
            assert state.last_comment_check == "2025-01-20T00:00:00Z"

    def test_first_interaction_creates_state(self, tmp_path):
        """First interaction (no existing state) initializes from change_info."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            info = self._make_change_info(current_version=5)
            update_state_after_command("doc1", info, command="cat", quiet=False)
            state = load_state("doc1")
            assert state is not None
            assert state.last_version == 5
            assert state.last_read_version == 5
            assert state.known_comment_ids == ["c1", "c2"]

    def test_non_read_command_does_not_set_read_version(self, tmp_path):
        """edit/write commands do not update last_read_version."""
        with patch("gdoc.state.STATE_DIR", tmp_path):
            save_state("doc1", DocState(last_read_version=5))
            info = self._make_change_info(current_version=10)
            update_state_after_command("doc1", info, command="edit", quiet=False)
            state = load_state("doc1")
            assert state.last_version == 10
            assert state.last_read_version == 5  # unchanged

    def test_last_seen_always_updated(self, tmp_path):
        with patch("gdoc.state.STATE_DIR", tmp_path):
            update_state_after_command("doc1", None, command="cat", quiet=True)
            state = load_state("doc1")
            assert state.last_seen != ""
            assert "T" in state.last_seen
```

Add `from unittest.mock import patch` at the top of the file (it may already be there).
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_state.py -v` — all tests pass.
Run: `.venv/bin/python -m pytest tests/ -v` — full suite passes.
  </verify>
  <done>State update integration tests cover all Decision #6/#14 rules, first interaction, read vs non-read commands.</done>
</task>

<task type="auto">
  <name>Task 7: Add --quiet flag to share and cp parser entries</name>
  <files>gdoc/cli.py, tests/test_cli.py</files>
  <action>
The researcher identified that `share` and `cp` commands are missing the `--quiet` flag in the argument parser, but CONTEXT Decision #2 says pre-flight runs on ALL DOC_ID commands (including share and cp).

**1. Add `--quiet` to `share_p` in `build_parser()`:**

After the `--role` argument on `share_p`, add:
```python
share_p.add_argument(
    "--quiet", action="store_true", help="Skip pre-flight checks"
)
```

**2. Add `--quiet` to `cp_p` in `build_parser()`:**

After the `title` argument on `cp_p`, add:
```python
cp_p.add_argument(
    "--quiet", action="store_true", help="Skip pre-flight checks"
)
```

**3. Add parser test in `tests/test_cli.py`:**

Add a test that verifies `--quiet` is accepted on share and cp:
```python
def test_share_accepts_quiet(self):
    # gdoc share DOC EMAIL --quiet should be accepted (stub, but parser works)
    ...

def test_cp_accepts_quiet(self):
    # gdoc cp DOC "title" --quiet should be accepted (stub, but parser works)
    ...
```

These are stubs today, but when Phase 6 implements them, the `--quiet` flag will already be wired into the parser.
  </action>
  <verify>
Run: `.venv/bin/python -m pytest tests/test_cli.py -v` — all tests pass.
Run: `.venv/bin/python -c "from gdoc.cli import build_parser; p = build_parser(); args = p.parse_args(['share', 'doc1', 'a@b.com', '--quiet']); print(args.quiet)"` — prints True.
Run: `.venv/bin/python -c "from gdoc.cli import build_parser; p = build_parser(); args = p.parse_args(['cp', 'doc1', 'title', '--quiet']); print(args.quiet)"` — prints True.
  </verify>
  <done>All DOC_ID commands now accept --quiet, consistent with CONTEXT Decision #2.</done>
</task>

</tasks>

<verification>
1. `gdoc/cli.py` — `cmd_cat` and `cmd_info` call `pre_flight` and `update_state_after_command`
2. `gdoc/state.py` — `update_state_after_command` handles quiet/non-quiet and read/non-read correctly
3. All existing tests still pass (with added awareness mocks)
4. New tests verify: pre_flight called, --quiet bypass, state update with version, error prevents state update
5. Full suite: `.venv/bin/python -m pytest tests/ -v`
6. Manual verification: banner appears on stderr before stdout content

Manual test (requires auth):
```bash
# First interaction — shows first-interaction banner
python -m gdoc cat DOC_ID

# Second run — shows "no changes" or change details
python -m gdoc cat DOC_ID

# Quiet mode — no banner
python -m gdoc cat DOC_ID --quiet
```
</verification>

<success_criteria>
- cmd_cat calls pre_flight before export_doc and updates state after success
- cmd_info calls pre_flight before get_file_info and updates state after success
- --quiet skips pre_flight entirely (no API calls)
- State update after cmd_cat sets last_read_version (cat is a read command)
- State update after cmd_info passes command_version from get_file_info response
- --quiet cat has stale version (Decision #14)
- --quiet info has fresh version from command response (Decision #14)
- --comments stub returns before pre_flight (no wasted API calls)
- Error in export_doc/get_file_info prevents state update
- First interaction creates new state file
- Non-read commands (edit) don't update last_read_version
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/03-phase-03/03-02-SUMMARY.md`
</output>
