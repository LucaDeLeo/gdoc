# Plan 04-01: `edit` Command — Find-and-Replace via Docs API

## Goal
Implement `gdoc edit DOC_ID "old" "new"` with `--all` and `--case-sensitive` flags, using Google Docs API v1 `replaceAllText`, with uniqueness pre-check, post-call reconciliation, awareness integration, and state tracking.

## Wave
1 of 2 — edit has no dependency on write; write (04-02) depends on state update changes made here.

## References
- CONTEXT.md Decisions: #1 (case-sensitivity), #3 (uniqueness pre-check), #4 (state update), #12 (post-edit version)
- Existing patterns: gdoc/api/drive.py, gdoc/cli.py (cmd_cat, cmd_info), tests/test_cat.py

---

## Tasks

### Task 1: Create `gdoc/api/docs.py` — Docs API v1 wrapper

**New file.** Mirrors `gdoc/api/drive.py` pattern.

```python
"""Google Docs API v1 wrapper functions with error translation."""

from functools import lru_cache
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

from gdoc.util import AuthError, GdocError


@lru_cache(maxsize=1)
def get_docs_service():
    """Build and cache a Docs API v1 service object."""
    from gdoc.auth import get_credentials
    creds = get_credentials()
    return build("docs", "v1", credentials=creds)


def _translate_http_error(e: HttpError, doc_id: str) -> None:
    """Translate HttpError for Docs API operations."""
    status = int(e.resp.status)
    if status == 401:
        raise AuthError("Authentication expired. Run `gdoc auth`.")
    if status == 403:
        raise GdocError(f"Permission denied: {doc_id}")
    if status == 404:
        raise GdocError(f"Document not found: {doc_id}")
    raise GdocError(f"API error ({status}): {e.reason}")


def replace_all_text(
    doc_id: str,
    old_text: str,
    new_text: str,
    match_case: bool = False,
) -> int:
    """Replace text in a document using replaceAllText.

    Args:
        doc_id: The document ID.
        old_text: Text to find.
        new_text: Replacement text.
        match_case: If True, case-sensitive matching.

    Returns:
        Number of occurrences changed (from API response).
    """
    try:
        service = get_docs_service()
        body = {
            "requests": [
                {
                    "replaceAllText": {
                        "containsText": {
                            "text": old_text,
                            "matchCase": match_case,
                        },
                        "replaceText": new_text,
                    }
                }
            ]
        }
        result = service.documents().batchUpdate(
            documentId=doc_id, body=body
        ).execute()

        # Extract occurrencesChanged from response
        replies = result.get("replies", [])
        if replies:
            return replies[0].get("replaceAllText", {}).get(
                "occurrencesChanged", 0
            )
        return 0
    except HttpError as e:
        _translate_http_error(e, doc_id)
```

**Tests:** `tests/test_api_docs.py`
- `test_get_docs_service_caches`: Verify @lru_cache returns same instance
- `test_replace_all_text_success`: Mock batchUpdate, assert correct request body, returns occurrencesChanged
- `test_replace_all_text_case_sensitive`: matchCase=True in request
- `test_replace_all_text_zero_occurrences`: Returns 0 when no matches
- `test_replace_all_text_empty_replies`: Returns 0 when replies list is empty
- `test_translate_401`: HttpError 401 → AuthError
- `test_translate_403`: HttpError 403 → GdocError "Permission denied"
- `test_translate_404`: HttpError 404 → GdocError "Document not found"
- `test_translate_500`: HttpError 500 → GdocError with status

### Task 2: Extend `gdoc/state.py` — Support edit/write `command_version`

**Edit existing file.** The `update_state_after_command` function currently only uses `command_version` when `command == "info" and quiet`. Extend it to also update `last_version` (NOT `last_read_version`) for edit/write commands (Decision #4).

Change in `update_state_after_command`:
```python
# Current (quiet block):
if quiet:
    if command == "info" and command_version is not None:
        state.last_version = command_version
        state.last_read_version = command_version

# Add after the quiet block, inside the elif change_info branch:
# After the existing version update code, add:
# Also accept command_version for edit/write when provided
# (used to prevent false "doc edited" banner on next command)

# New logic: after the existing elif block, add a final check:
if command_version is not None and command not in ("cat", "info"):
    state.last_version = command_version
```

Wait — actually, let me re-read the current code more carefully.

The current flow:
1. If `quiet`: only update version for `info` commands
2. Elif `change_info is not None`: update from pre-flight data

For edit/write, when NOT quiet, pre_flight runs and `change_info.current_version` updates `last_version` already. But the pre_flight version is captured BEFORE the edit/write happens. After the edit, the version changes. So we need to update `last_version` with the POST-edit/write version.

The fix: after the existing if/elif block, add an unconditional override when `command_version` is provided and command is not a read command. This ensures the post-mutation version is stored.

```python
# At end of function, before save_state:
if command_version is not None and command not in ("cat", "info"):
    state.last_version = command_version
```

This is safe because:
- For `cat`/`info`, the existing logic handles `command_version` correctly
- For `edit`/`write`, the `command_version` from the mutation response takes precedence over the pre-flight version

**Tests:** Add to `tests/test_state.py`
- `test_edit_command_version_updates_last_version`: edit with command_version → last_version updated
- `test_edit_command_version_does_not_update_read_version`: edit with command_version → last_read_version unchanged
- `test_write_command_version_updates_last_version`: same for write
- `test_edit_with_preflight_then_command_version`: pre-flight sets version, command_version overrides last_version

### Task 3: Implement `cmd_edit` in `gdoc/cli.py`

**Edit existing file.** Replace `cmd_stub` binding for edit with real `cmd_edit` handler.

Flow (per CONTEXT.md Decision #3):

```python
def cmd_edit(args) -> int:
    """Handler for `gdoc edit`."""
    doc_id = _resolve_doc_id(args.doc)
    quiet = getattr(args, "quiet", False)
    replace_all = getattr(args, "all", False)
    case_sensitive = getattr(args, "case_sensitive", False)

    # Pre-flight awareness check
    from gdoc.notify import pre_flight
    change_info = pre_flight(doc_id, quiet=quiet)

    # Conflict warning (warn but don't block, per spec)
    if change_info and change_info.has_conflict:
        print("WARN: doc changed since last read", file=sys.stderr)

    old_text = args.old_text
    new_text = args.new_text

    # Uniqueness pre-check (skip when --all, per Decision #3)
    if not replace_all:
        from gdoc.api.drive import export_doc
        plain_text = export_doc(doc_id, mime_type="text/plain")

        if case_sensitive:
            count = plain_text.count(old_text)
        else:
            count = plain_text.lower().count(old_text.lower())

        if count == 0:
            raise GdocError("no match found", exit_code=3)
        if count > 1:
            raise GdocError(
                f"multiple matches ({count} found). Use --all",
                exit_code=3,
            )

    # Perform replacement via Docs API
    from gdoc.api.docs import replace_all_text
    occurrences = replace_all_text(
        doc_id, old_text, new_text, match_case=case_sensitive,
    )

    # Post-call reconciliation
    if occurrences == 0:
        raise GdocError("no match found", exit_code=3)

    # Warn if pre-check count != API count (only relevant without --all)
    if not replace_all and occurrences > 1:
        print(
            f"WARN: expected 1 match but API replaced {occurrences}; "
            "text/plain export may differ from API matching",
            file=sys.stderr,
        )

    # Get post-edit version for state tracking (Decision #12)
    from gdoc.api.drive import get_file_version
    version_data = get_file_version(doc_id)
    command_version = version_data.get("version")

    # Output
    from gdoc.format import get_output_mode, format_json
    mode = get_output_mode(args)
    label = "occurrence" if occurrences == 1 else "occurrences"
    if mode == "json":
        print(format_json(replaced=occurrences))
    else:
        print(f"OK replaced {occurrences} {label}")

    # Update state
    from gdoc.state import update_state_after_command
    update_state_after_command(
        doc_id, change_info, command="edit",
        quiet=quiet, command_version=command_version,
    )

    return 0
```

Wire in parser: change `edit_p.set_defaults(func=cmd_stub)` → `edit_p.set_defaults(func=cmd_edit)`.

**Tests:** `tests/test_edit.py`

Helper:
```python
def _make_args(**overrides):
    defaults = {
        "command": "edit",
        "doc": "abc123",
        "old_text": "hello",
        "new_text": "world",
        "all": False,
        "case_sensitive": False,
        "json": False,
        "verbose": False,
        "quiet": False,
    }
    defaults.update(overrides)
    return SimpleNamespace(**defaults)
```

Test classes and cases:

**TestEditBasic:**
- `test_edit_single_match`: Mock export_doc returns text with 1 match, replace_all_text returns 1 → "OK replaced 1 occurrence", exit 0
- `test_edit_replaces_text`: Verify replace_all_text called with correct args (old_text, new_text, match_case=False)
- `test_edit_case_sensitive`: --case-sensitive → match_case=True passed to API, and pre-check uses str.count (not lowered)
- `test_edit_url_input`: Full URL resolved to doc ID

**TestEditAll:**
- `test_edit_all_skips_precheck`: --all → export_doc NOT called, replace_all_text called directly
- `test_edit_all_multiple_matches`: occurrences=5 → "OK replaced 5 occurrences", exit 0
- `test_edit_all_zero_matches`: occurrences=0 → GdocError exit 3

**TestEditPrecheck:**
- `test_edit_no_match_precheck`: export returns text without match → GdocError "no match found" exit 3, replace_all_text NOT called
- `test_edit_multiple_matches_precheck`: export returns text with 3 matches → GdocError "multiple matches (3 found). Use --all" exit 3, replace_all_text NOT called
- `test_edit_case_insensitive_precheck`: "Hello" in text, searching "hello" → count=1 (case insensitive)
- `test_edit_case_sensitive_precheck_no_match`: "Hello" in text, searching "hello" with --case-sensitive → count=0 → error

**TestEditReconciliation:**
- `test_edit_api_replaces_more_than_expected`: pre-check count=1, API returns 3 → exit 0, WARN on stderr
- `test_edit_api_zero_after_precheck`: pre-check count=1, API returns 0 → GdocError exit 3

**TestEditJson:**
- `test_edit_json_output`: --json → `{"ok": true, "replaced": 1}`
- `test_edit_all_json_output`: --all, occurrences=3 → `{"ok": true, "replaced": 3}`

**TestEditConflict:**
- `test_edit_conflict_warns_but_proceeds`: change_info.has_conflict=True → WARN on stderr, edit still executes, exit 0
- `test_edit_no_conflict_no_warning`: change_info.has_conflict=False → no WARN on stderr

**TestEditAwareness:**
- `test_preflight_called`: pre_flight called with doc_id and quiet=False
- `test_quiet_skips_preflight`: --quiet → pre_flight called with quiet=True
- `test_state_updated_with_version`: update_state_after_command called with command="edit" and command_version from get_file_version
- `test_no_state_update_on_precheck_error`: GdocError from pre-check → update_state_after_command NOT called
- `test_no_state_update_on_api_error`: GdocError from replace_all_text → update_state_after_command NOT called

**TestEditErrors:**
- `test_edit_invalid_doc_id`: Invalid URL → GdocError exit 3
- `test_edit_api_permission_denied`: replace_all_text raises GdocError → propagates
- `test_edit_api_auth_error`: replace_all_text raises AuthError → propagates

### Task 4: Update integration tests in `tests/test_cli.py`

When `edit` is no longer a stub, several subprocess-based tests that use `edit` and assert `returncode == 4` will break (they'll get exit code 2 for auth error instead).

**Tests to update:**

1. `TestExitCode4OnStubs.test_edit_stub` — change to verify no longer a stub:
```python
def test_edit_no_longer_stub(self):
    result = run_gdoc("edit", "doc123", "old", "new")
    assert result.returncode != 4  # no longer a stub
```

2. Four tests in `TestMutuallyExclusiveFlags` that use `edit` as a convenient stub command and assert `returncode == 4` (lines 47-60). Switch these to use a still-stubbed command (e.g., `comment`) to preserve original test intent:
   - `test_json_accepted` — change `edit doc123 old new` → `comment doc123 "text"`, keep `assert result.returncode == 4`
   - `test_verbose_accepted` — same change
   - `test_json_after_subcommand` — change `edit 1aBcDeFg old new --json` → `comment 1aBcDeFg "text" --json`, keep `assert result.returncode == 4`
   - `test_verbose_after_subcommand` — change `edit doc123 old new --verbose` → `comment doc123 "text" --verbose`, keep `assert result.returncode == 4`

3. `TestErrorFormat.test_stub_error_prefix` — uses `edit` and checks `stderr.startswith("ERR: ")`. With real edit, auth errors still produce `ERR: Authentication expired...` which starts with `ERR: `. However, to keep the test cleanly about stubs, switch to a still-stubbed command (e.g., `comment doc123 "text"`).

---

## Files Changed

| File | Action | Description |
|------|--------|-------------|
| `gdoc/api/docs.py` | CREATE | Docs API v1 service factory + replaceAllText wrapper |
| `gdoc/state.py` | EDIT | Extend update_state_after_command for edit/write command_version |
| `gdoc/cli.py` | EDIT | Add cmd_edit handler, rewire parser |
| `tests/test_api_docs.py` | CREATE | Docs API wrapper tests |
| `tests/test_edit.py` | CREATE | Edit command handler tests |
| `tests/test_state.py` | EDIT | Add edit/write state update tests |
| `tests/test_cli.py` | EDIT | Update edit stub test |

## Verification

1. `pytest tests/test_api_docs.py -v` — all pass
2. `pytest tests/test_edit.py -v` — all pass
3. `pytest tests/test_state.py -v` — all pass (including new tests)
4. `pytest tests/test_cli.py -v` — all pass (updated stub test)
5. `pytest tests/ -v` — full suite passes, no regressions
6. `bash scripts/check-no-stubs.sh` — edit no longer detected as stub
7. `ruff check gdoc/ tests/` — no lint errors
