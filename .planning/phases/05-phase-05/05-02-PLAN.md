---
phase: 05-comments
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - gdoc/annotate.py
  - gdoc/cli.py
  - tests/test_annotate.py
  - tests/test_cat.py
autonomous: true

must_haves:
  truths:
    - "User can export a doc with line-numbered content and comment annotations using `cat DOC_ID --comments`"
    - "Only open comments are annotated by default; `--all` includes resolved with `[#ID resolved]` markers"
    - "Anchored comments appear after the line containing their anchor text; unanchored comments appear in a bottom section"
  artifacts:
    - path: "gdoc/annotate.py"
      provides: "Line-numbered comment annotation engine"
      contains: "annotate_markdown"
    - path: "tests/test_annotate.py"
      provides: "Annotation edge case tests"
      min_lines: 80
  key_links:
    - from: "gdoc/cli.py"
      to: "gdoc/annotate.py"
      via: "annotate_markdown called from cmd_cat"
      pattern: "from gdoc\\.annotate import annotate_markdown"
    - from: "gdoc/cli.py"
      to: "gdoc/api/comments.py"
      via: "list_comments with include_anchor=True"
      pattern: "include_anchor=True"
---

<objective>
Implement the `cat --comments` annotated view with line-numbered content and inline comment annotations, including the pure-logic annotation engine.

Purpose: Delivers requirement READ-02 -- the "full picture" mode that shows document content with comment annotations. This is the most complex piece of Phase 5, involving substring-based anchor mapping with edge case handling for ambiguity, deletion, and short anchors.

Output: Working `cat --comments` command with `annotate.py` module and comprehensive edge case test coverage.
</objective>

<execution_context>
@/Users/luca/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luca/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-05/CONTEXT.md
@.planning/phases/05-phase-05/05-RESEARCH.md
@.planning/phases/05-phase-05/05-01-SUMMARY.md
@gdoc/cli.py
@gdoc/api/comments.py
@gdoc.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: annotate.py module with edge case handling + tests</name>
  <files>gdoc/annotate.py, tests/test_annotate.py</files>
  <action>
**Create `gdoc/annotate.py` with `annotate_markdown(markdown, comments, show_resolved=False) -> str`.**

This is a pure-logic module. No API calls, no imports from gdoc.api.

**Input:**
- `markdown: str` — raw markdown content from `export_doc`.
- `comments: list[dict]` — from `list_comments(include_anchor=True)`. Each comment dict has: `id`, `content`, `author` (with `displayName`/`emailAddress`), `resolved`, `createdTime`, `replies` (list), and optionally `quotedFileContent` (with `value`).
- `show_resolved: bool` — if True, include resolved comments with `[resolved]` status marker. If False (default), comments list should already be filtered (but defensive filtering is fine).

**Output format (per spec at gdoc.md:46-74 and CONTEXT.md):**
```
     1\t# Heading
     2\t
     3\tSome content line.
      \t  [#1 open] alice@co.com on "content line":
      \t    "This needs a citation"
      \t    > bob@co.com: "Done"
     4\t
     5\tMore content.
      \t[UNANCHORED]
      \t  [#5 open] dave@co.com: "General feedback"
```

Line number format: `f"{n:>6}\t"` for numbered lines (6-char right-aligned number + tab). Annotation lines: `"      \t"` (6 spaces + tab).

**Algorithm:**

1. Split markdown into lines.
2. Classify each comment as anchored or unanchored:
   - Unanchored: no `quotedFileContent` key, or `quotedFileContent` is None, or `quotedFileContent.value` is empty.
   - Short anchor: `quotedFileContent.value` exists but `len(value.strip()) < 4` -- treat as unanchored with `[anchor too short]` fallback note.
   - Anchored: has `quotedFileContent.value` with length >= 4.

3. For each anchored comment, find anchor in the full markdown string using `str.find()`:
   - `pos = markdown.find(anchor_text)` — first occurrence.
   - Check for multiple matches: `second_pos = markdown.find(anchor_text, pos + 1)`. If `second_pos != -1`, treat as unanchored with `[anchor ambiguous]`.
   - If `pos == -1`, treat as unanchored with `[anchor deleted]`.
   - If single match: count newlines in `markdown[:pos + len(anchor_text)]` to find the line number (0-indexed). For multi-line anchors (anchor text contains `\n`), annotate after the **last** line of the match span — count newlines up to `pos + len(anchor_text)`.
   - Store mapping: `line_number -> list of (comment, fallback_note)`.

4. Build output:
   - For each line (1-indexed), emit `f"{line_num:>6}\t{line_content}"`.
   - If there are comments mapped to this line, emit annotation block for each comment (un-numbered lines).
   - Annotation format for anchored comment:
     ```
           \t  [#ID STATUS] author on "anchor_text_truncated":
           \t    "comment content"
           \t    > reply_author: "reply content"
     ```
     Status: `open` or `resolved`. Author: `emailAddress` or `displayName`. Truncate anchor text display to 40 chars (append `...` if truncated). Only show replies with `content` (skip action-only replies like resolve/reopen).

5. After all content lines, if there are unanchored comments:
   - Emit `"      \t[UNANCHORED]"`.
   - For each unanchored comment, emit annotation block:
     ```
           \t  [#ID STATUS] author: "comment content"
     ```
     If the comment has a fallback note (e.g., `[anchor ambiguous]`), append it after the status: `[#ID open] [anchor ambiguous] author: "content"`.

**Helper functions (internal):**
- `_format_author(author_dict) -> str` — `emailAddress` or `displayName` or `"unknown"`.
- `_format_annotation_block(comment, anchor_text=None, fallback_note="") -> list[str]` — returns list of un-numbered annotation lines.

**tests/test_annotate.py — Pure logic tests, no mocking needed:**

Create helper to build comment dicts: `_make_comment(id, content, author_email, anchor=None, resolved=False, replies=None)`.

Per CONTEXT.md test plan:

- `test_single_match_annotation` — comment anchored to unique text, annotation placed after correct line.
- `test_multiple_matches_ambiguous` — anchor text appears twice in markdown, comment placed in unanchored section with `[anchor ambiguous]`.
- `test_zero_matches_deleted` — anchor text not in markdown, comment placed in unanchored section with `[anchor deleted]`.
- `test_short_anchor_too_short` — anchor text < 4 chars, comment placed in unanchored section with `[anchor too short]`.
- `test_multiline_anchor` — anchor spans 2 lines, annotation placed after last line of match span.
- `test_multiline_anchor_multiple_matches` — multi-line anchor appears twice, treated as `[anchor ambiguous]`.
- `test_unanchored_comment` — no `quotedFileContent`, placed in bottom unanchored section.
- `test_mixed_anchored_and_unanchored` — doc with both types renders correctly; anchored inline, unanchored at bottom.
- `test_empty_document_with_comments` — empty markdown string, all comments in unanchored section.
- `test_resolved_shown_with_marker` — `show_resolved=True`, resolved comment shows `[#ID resolved]` status.
- `test_line_number_format` — verify `%6d\t` format for content lines and `      \t` for annotation lines.
- `test_replies_shown` — comment with text replies displayed with `>` prefix.
- `test_action_only_replies_hidden` — resolve/reopen action replies (no content) are not displayed in annotation.
  </action>
  <verify>`.venv/bin/python -m pytest tests/test_annotate.py -v` — all tests pass.</verify>
  <done>
- `gdoc/annotate.py` exists with `annotate_markdown` function.
- All anchor mapping rules from CONTEXT.md implemented: single match, multiple match (ambiguous), zero match (deleted), short anchor, multi-line anchor.
- Output format matches spec: `%6d\t` for content, `      \t` for annotations.
- All 13 edge case tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire cat --comments in cmd_cat + integration tests</name>
  <files>gdoc/cli.py, tests/test_cat.py</files>
  <action>
**Modify `cmd_cat` in gdoc/cli.py:**

Replace the existing stub block (lines 32-34):
```python
if getattr(args, "comments", False):
    print("ERR: cat --comments is not yet implemented", file=sys.stderr)
    return 4  # STUB -- removed when real implementation added
```

With the real implementation:

```python
if getattr(args, "comments", False):
    # Pre-flight awareness check
    quiet = getattr(args, "quiet", False)
    from gdoc.notify import pre_flight
    change_info = pre_flight(doc_id, quiet=quiet)

    # Fetch markdown content
    from gdoc.api.drive import export_doc
    markdown = export_doc(doc_id, mime_type="text/markdown")

    # Fetch comments with anchor data
    from gdoc.api.comments import list_comments
    include_resolved = getattr(args, "all", False)
    comments = list_comments(
        doc_id,
        include_resolved=include_resolved,
        include_anchor=True,
    )

    # Build annotated output
    from gdoc.annotate import annotate_markdown
    annotated = annotate_markdown(markdown, comments, show_resolved=include_resolved)

    from gdoc.format import get_output_mode, format_json
    mode = get_output_mode(args)
    if mode == "json":
        print(format_json(content=annotated))
    else:
        print(annotated, end="")

    # Update state
    from gdoc.state import update_state_after_command
    update_state_after_command(doc_id, change_info, command="cat", quiet=quiet)

    return 0
```

Key points:
- `cat --comments` always uses markdown (not plain text) per CONTEXT.md Decision #1.
- `include_resolved` is controlled by `--all` flag (added to cat parser in Plan 05-01).
- `include_anchor=True` requests `quotedFileContent` from API (per CONTEXT.md Decision #5).
- JSON mode wraps the annotated text in the standard format, matching existing `cat --json` shape.
- State update uses `command="cat"` which sets `last_read_version` (it's a read command).

**Extend tests/test_cat.py:**

Add tests for the `--comments` path:

- `test_cat_comments_calls_list_comments_with_anchor` — verify `list_comments` called with `include_anchor=True` and `include_resolved=False`.
- `test_cat_comments_all_includes_resolved` — verify `list_comments` called with `include_resolved=True` when `--all` passed.
- `test_cat_comments_output_annotated` — mock export_doc to return markdown, mock list_comments to return comments, verify stdout contains annotated format (line numbers, annotation lines).
- `test_cat_comments_json_output` — verify JSON output wraps annotated content.
- `test_cat_comments_no_stub_exit_code` — verify exit code is 0 (not 4 stub).
- `test_cat_comments_state_update` — verify `update_state_after_command` called with command="cat".
  </action>
  <verify>`.venv/bin/python -m pytest tests/test_cat.py tests/test_annotate.py -v` — all tests pass. Then `.venv/bin/python -m pytest tests/ -v` — full suite passes, no regressions. Then `bash scripts/check-no-stubs.sh` — no comment-related stubs remain (only share/new/cp stubs for Phase 6).</verify>
  <done>
- `cat --comments` produces line-numbered annotated output with inline comment annotations.
- `cat --comments --all` includes resolved comments with `[resolved]` markers.
- JSON mode works for `cat --comments --json`.
- The STUB return code 4 is removed for `cat --comments`.
- State is updated correctly after `cat --comments`.
- All tests pass, no regressions.
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
.venv/bin/python -m pytest tests/ -v

# No comment-related stubs remain
bash scripts/check-no-stubs.sh
# Only share/new/cp stubs should remain (Phase 6)

# Verify annotate module exists and is importable
.venv/bin/python -c "from gdoc.annotate import annotate_markdown; print('OK')"

# Verify cat --comments no longer returns exit 4
.venv/bin/python -c "
from gdoc.cli import build_parser
p = build_parser()
args = p.parse_args(['cat', 'FAKE_ID', '--comments'])
print('func:', args.func.__name__)
# Should print cmd_cat, not cmd_stub
"
```
</verification>

<success_criteria>
- `cat DOC_ID --comments` outputs line-numbered content with inline comment annotations.
- Anchor mapping handles all edge cases: single match, ambiguous, deleted, short, multi-line.
- Unanchored comments appear in a labeled section at the bottom.
- `--all` flag controls resolved comment inclusion with `[resolved]` markers.
- JSON mode wraps annotated content correctly.
- No regressions in existing test suite.
- No stubs remain for any Phase 5 commands.
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-05/05-02-SUMMARY.md`
</output>
